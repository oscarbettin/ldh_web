{% extends 'base.html' %}

{% block title %}Editor Visual de Diseño - {{ disenio.nombre }}{% endblock %}

{% block extra_css %}
<style>
    .editor-container {
        display: flex;
        height: calc(100vh - 120px);
        gap: 15px;
        padding: 15px;
    }
    
    .toolbox {
        width: 280px;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        overflow-y: auto;
    }
    
    .toolbox h6 {
        font-size: 0.9rem;
        font-weight: 600;
        color: #495057;
        margin-bottom: 10px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .toolbox-item {
        background: white;
        border: 2px dashed #ced4da;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 10px;
        cursor: move;
        transition: all 0.2s;
        user-select: none;
    }
    
    .toolbox-item:hover {
        border-color: #007bff;
        background: #e7f3ff;
        transform: translateX(5px);
    }
    
    .toolbox-item.dragging {
        opacity: 0.5;
    }
    
    .toolbox-item i {
        margin-right: 8px;
        color: #007bff;
    }
    
    .canvas-area {
        flex: 1;
        background: #e9ecef;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 30px;
        overflow: auto;
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    
    .canvas-wrapper {
        position: relative;
        display: inline-block;
    }
    
    /* Regla horizontal en píxeles */
    .ruler-horizontal {
        position: absolute;
        height: 30px;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-bottom: 2px solid #495057;
        margin-bottom: 0;
        overflow: hidden; /* Ocultar marcas que excedan el ancho de la regla */
        font-family: 'Courier New', monospace;
        font-size: 10px;
        user-select: none;
        top: 0;
        z-index: 10;
    }
    
    /* Regla vertical en píxeles */
    .ruler-vertical {
        position: absolute;
        width: 30px;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-right: 2px solid #495057;
        margin-right: 0;
        overflow: hidden; /* Ocultar marcas que excedan el alto de la regla */
        font-family: 'Courier New', monospace;
        font-size: 10px;
        user-select: none;
        left: 0;
        z-index: 10;
    }
    
    .ruler-scale {
        position: relative;
        top: 0;
        left: 0;
        height: 100%;
        /* El ancho se establece dinámicamente en JavaScript para que coincida con anchoReglaVisual */
        display: block;
        overflow: hidden; /* Ocultar marcas que excedan el ancho */
    }
    
    .ruler-scale-vertical {
        position: relative;
        top: 0;
        left: 0;
        width: 100%;
        /* El alto se establece dinámicamente en JavaScript para que coincida con altoReglaVisual */
        display: block;
        overflow: hidden; /* Ocultar marcas que excedan el alto */
    }
    
    .ruler-mark {
        position: absolute;
        border-left: 1px solid #6c757d;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    
    .ruler-mark.major {
        border-left-width: 2px;
        border-left-color: #495057;
        height: 20px;
    }
    
    .ruler-mark.minor {
        height: 10px;
        border-left-color: #adb5bd;
    }
    
    .ruler-mark.micro {
        height: 5px;
        border-left-color: #dee2e6;
    }
    
    .ruler-mark-vertical {
        position: absolute;
        border-top: 1px solid #6c757d;
        width: 100%;
        display: flex;
        flex-direction: row;
        align-items: center;
    }
    
    .ruler-mark-vertical.major {
        border-top-width: 2px;
        border-top-color: #495057;
        width: 20px;
    }
    
    .ruler-mark-vertical.minor {
        width: 10px;
        border-top-color: #adb5bd;
    }
    
    .ruler-mark-vertical.micro {
        width: 5px;
        border-top-color: #dee2e6;
    }
    
    .ruler-label {
        position: absolute;
        top: 2px;
        left: 2px;
        font-size: 9px;
        color: #495057;
        font-weight: 600;
        white-space: nowrap;
    }
    
    .ruler-label-vertical {
        position: absolute;
        font-size: 9px;
        color: #495057;
        font-weight: 600;
        white-space: nowrap;
        transform: rotate(-90deg);
        transform-origin: center center;
        width: 30px;
        text-align: center;
        left: 8px;
        margin-left: 0;
        z-index: 1;
    }
    
    .canvas-controls {
        position: sticky;
        top: 0;
        z-index: 1000;
        text-align: center;
        padding: 10px;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin-bottom: 15px;
    }
    
    .report-canvas {
        background: white;
        width: 210mm; /* A4 width por defecto */
        height: 297mm; /* A4 height por defecto */
        margin: 30px auto 0 auto; /* Margen superior para la regla */
        padding: 0;
        box-shadow: 0 0 20px rgba(0,0,0,0.1);
        position: relative;
        aspect-ratio: 210 / 297; /* Proporción A4 */
        transition: transform 0.2s ease;
    }
    
    .canvas-content {
        position: relative;
        width: 100%;
        height: 100%;
    }
    
    /* Líneas punteadas para márgenes de la hoja */
    .report-canvas::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 1;
    }
    
    .margen-linea {
        position: absolute;
        pointer-events: none;
        z-index: 100;
        background: transparent;
    }
    
    .margen-linea.vertical {
        width: 1px;
        border-left: 2px dashed #ff6b6b;
    }
    
    .margen-linea.horizontal {
        height: 1px;
        border-top: 2px dashed #ff6b6b;
    }
    
    .report-canvas.zoom-applied {
        transform-origin: top center;
    }
    
    .report-canvas[data-tamano="Letter"] {
        width: 216mm;
        height: 279mm;
        aspect-ratio: 216 / 279;
    }
    
    .report-canvas[data-tamano="Legal"] {
        width: 216mm;
        height: 356mm;
        aspect-ratio: 216 / 356;
    }
    
    .report-canvas[data-tamano="personalizado"] {
        /* Se establece dinámicamente via JavaScript */
    }
    
    @media screen {
        /* En pantalla, no aplicar escala automática - se controla con zoom */
        .report-canvas {
            margin-bottom: 20px;
        }
    }
    
    #report-canvas.drag-over {
        border: 2px dashed #007bff !important;
        background: #e7f2ff !important;
    }
    
    .drop-zone {
        min-height: 50px;
        border: 2px dashed transparent;
        border-radius: 4px;
        position: relative;
        margin-bottom: 10px;
    }
    
    .drop-zone.drag-over {
        border-color: #007bff;
        background: #e7f2ff;
    }
    
    .element-item {
        position: relative;
        padding: 10px;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        margin-bottom: 10px;
        background: white;
        cursor: move;
        box-sizing: border-box;
        min-width: 50px;
        min-height: 20px;
        display: inline-block;
        vertical-align: top;
    }
    
    /* Permitir posicionamiento absoluto si se configura */
    .element-item.posicion-absoluta {
        position: absolute;
        margin: 0;
    }
    
    /* Estilos para el logo */
    .element-item.element-logo {
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
    }
    
    .element-logo-content {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        min-height: 50px;
        box-sizing: border-box;
        padding: 0;
    }
    
    .element-logo-content img {
        max-width: 100% !important;
        max-height: 100% !important;
        width: auto !important;
        height: auto !important;
        display: block;
        object-fit: contain;
        margin: 0 auto;
    }
    
    .element-item:hover {
        border-color: #007bff;
        box-shadow: 0 2px 8px rgba(0,123,255,0.2);
    }
    
    .element-item.selected {
        border-color: #007bff;
        border-width: 2px;
        box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
    }
    
    .element-item .editable-text {
        word-wrap: break-word;
        overflow-wrap: break-word;
    }
    
    .element-controls {
        position: absolute;
        top: -30px;
        right: 0;
        background: #007bff;
        border-radius: 4px 4px 0 0;
        padding: 4px 8px;
        display: none;
        gap: 5px;
    }
    
    .element-item.selected .element-controls {
        display: flex;
    }
    
    .element-controls button {
        background: white;
        border: none;
        padding: 2px 8px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 0.8rem;
    }
    
    .element-controls button:hover {
        background: #f8f9fa;
    }
    
    .editable-text {
        min-height: 20px;
        outline: none;
        cursor: text;
    }
    
    .editable-text:focus {
        background: #fff3cd !important;
        border-radius: 3px;
    }
    
    /* Asegurar que los estilos del contenedor se hereden en editable-text dentro de secciones */
    .seccion-titulo-preview .editable-text {
        font-family: inherit !important;
        font-size: inherit !important;
        font-weight: inherit !important;
        font-style: inherit !important;
        color: inherit !important;
        text-align: inherit !important;
        background-color: transparent !important;
    }
    
    /* Forzar estilos en seccion-titulo-preview con máxima especificidad */
    .element-item .seccion-preview .seccion-titulo-preview {
        font-family: inherit !important;
        font-size: inherit !important;
        font-weight: inherit !important;
        font-style: inherit !important;
        color: inherit !important;
        text-align: inherit !important;
        background-color: inherit !important;
    }
    
    /* Los estilos inline con !important deberían tener prioridad sobre cualquier CSS */
    
    .properties-panel {
        width: 300px;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        overflow-y: auto;
    }
    
    .properties-panel .nav-tabs {
        border-bottom: 2px solid #dee2e6;
    }
    
    .properties-panel .nav-link {
        color: #495057;
        font-size: 0.85rem;
        padding: 8px 12px;
    }
    
    .properties-panel .nav-link.active {
        color: #007bff;
        font-weight: 600;
        border-bottom: 2px solid #007bff;
    }
    
    .properties-panel .tab-content {
        margin-top: 10px;
    }
    
    .properties-panel h6 {
        font-size: 0.9rem;
        font-weight: 600;
        margin-bottom: 15px;
        color: #495057;
    }
    
    .property-group {
        margin-bottom: 10px;
    }
    
    .property-group label {
        font-size: 0.75rem;
        font-weight: 500;
        color: #495057;
        display: block;
        margin-bottom: 3px;
    }
    
    .property-group input,
    .property-group select,
    .property-group textarea {
        width: 100%;
        padding: 4px 8px;
        border: 1px solid #ced4da;
        border-radius: 3px;
        font-size: 0.85rem;
    }
    
    /* Estilo Ribbon - Grupos compactos */
    .ribbon-group {
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 8px;
        margin-bottom: 8px;
        background: #f8f9fa;
    }
    
    .ribbon-group-title {
        font-size: 0.7rem;
        font-weight: 600;
        color: #6c757d;
        text-transform: uppercase;
        margin-bottom: 6px;
        padding-bottom: 4px;
        border-bottom: 1px solid #dee2e6;
    }
    
    .ribbon-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
    }
    
    .ribbon-button {
        padding: 6px 10px;
        border: 1px solid #ced4da;
        border-radius: 3px;
        background: white;
        cursor: pointer;
        font-size: 0.8rem;
        display: flex;
        align-items: center;
        gap: 4px;
        transition: all 0.2s;
    }
    
    .ribbon-button:hover {
        background: #e9ecef;
        border-color: #adb5bd;
    }
    
    .ribbon-button.active {
        background: #007bff;
        color: white;
        border-color: #007bff;
    }
    
    .ribbon-button-group {
        display: flex;
        gap: 2px;
        border: 1px solid #ced4da;
        border-radius: 3px;
        overflow: hidden;
        background: white;
    }
    
    .ribbon-button-group button {
        border: none;
        border-right: 1px solid #ced4da;
        padding: 6px 10px;
        background: white;
        cursor: pointer;
        font-size: 0.8rem;
    }
    
    .ribbon-button-group button:last-child {
        border-right: none;
    }
    
    .ribbon-button-group button:hover {
        background: #e9ecef;
    }
    
    .ribbon-button-group button.active {
        background: #007bff;
        color: white;
    }
    
    .ribbon-input-compact {
        display: inline-flex;
        align-items: center;
        gap: 4px;
    }
    
    .ribbon-input-compact input {
        width: 60px;
        padding: 4px 6px;
        font-size: 0.8rem;
    }
    
    .ribbon-select-compact {
        width: auto;
        min-width: 100px;
        padding: 4px 6px;
        font-size: 0.8rem;
    }
    
    .btn-save {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
        padding: 12px 24px;
        font-size: 1rem;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
</style>
{% endblock %}

{% block content %}
<div class="editor-container">
    <!-- Toolbox - Elementos disponibles -->
    <div class="toolbox">
        <h6><i class="bi bi-grid"></i> Elementos</h6>
        
        <div class="toolbox-item" draggable="true" data-type="logo">
            <i class="bi bi-image"></i> <strong>Logo</strong>
            <div class="small text-muted">Imagen del logo</div>
        </div>
        
        <div class="toolbox-item" draggable="true" data-type="texto-laboratorio">
            <i class="bi bi-text-left"></i> <strong>Texto Laboratorio</strong>
            <div class="small text-muted">Nombre del laboratorio</div>
        </div>
        
        <div class="toolbox-item" draggable="true" data-type="titulo">
            <i class="bi bi-type-h1"></i> <strong>H1 Título</strong>
            <div class="small text-muted">Título principal del informe</div>
        </div>
        
        <div class="toolbox-item" draggable="true" data-type="subtitulo">
            <i class="bi bi-type-h2"></i> <strong>H2 Subtítulo</strong>
            <div class="small text-muted">Subtítulo del informe</div>
        </div>
        
        <div class="toolbox-item" draggable="true" data-type="separador">
            <i class="bi bi-hr"></i> <strong>Separador</strong>
            <div class="small text-muted">Línea divisoria</div>
        </div>
        
        <div class="toolbox-item" draggable="true" data-type="protocolo-fecha">
            <i class="bi bi-calendar-check"></i> <strong>Protocolo y Fecha</strong>
            <div class="small text-muted">Protocolo y fecha de ingreso</div>
        </div>
        <div class="toolbox-item" draggable="true" data-type="datos-paciente">
            <i class="bi bi-person"></i> <strong>Datos del Paciente</strong>
            <div class="small text-muted">Información del paciente</div>
        </div>
        <div class="toolbox-item" draggable="true" data-type="datos-medico">
            <i class="bi bi-person-badge"></i> <strong>Datos del Médico</strong>
            <div class="small text-muted">Información del médico</div>
        </div>
        <div class="toolbox-item" draggable="true" data-type="datos-paciente-medico">
            <i class="bi bi-people"></i> <strong>Datos del Paciente y Médico</strong>
            <div class="small text-muted">Información combinada del paciente y médico</div>
        </div>
        
        <div class="toolbox-item" draggable="true" data-type="texto-libre">
            <i class="bi bi-textarea-resize"></i> <strong>Texto Libre</strong>
            <div class="small text-muted">Campo de texto editable</div>
        </div>
        
        <!-- Secciones dinámicas (se actualizarán según tipoEstudioActual) -->
        <div id="toolbox-secciones">
            <!-- Se cargarán dinámicamente con JavaScript -->
        </div>
        
        <div class="toolbox-item" draggable="true" data-type="espacio">
            <i class="bi bi-arrows-vertical"></i> <strong>Espacio</strong>
            <div class="small text-muted">Espacio en blanco</div>
        </div>
    </div>
    
    <!-- Canvas - Área de diseño -->
    <div class="canvas-area">
        <div class="canvas-controls mb-3">
            <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                <div>
                    <label class="me-2"><strong>Tamaño de Papel:</strong></label>
                    <select id="tamano-papel" class="form-select d-inline-block" style="width: auto;" onchange="cambiarTamanoPapel(this.value)">
                        <option value="A4" selected>A4 (210 × 297 mm)</option>
                        <option value="Letter">Letter (216 × 279 mm)</option>
                        <option value="Legal">Legal (216 × 356 mm)</option>
                        <option value="personalizado">Personalizado</option>
                    </select>
                </div>
                <div class="d-flex align-items-center gap-2">
                    <label><strong>Zoom:</strong></label>
                    <button class="btn btn-sm btn-outline-secondary" onclick="ajustarZoom(-10)" title="Alejar">
                        <i class="bi bi-zoom-out"></i>
                    </button>
                    <span id="zoom-level" style="min-width: 60px; text-align: center; font-weight: bold;">100%</span>
                    <button class="btn btn-sm btn-outline-secondary" onclick="ajustarZoom(10)" title="Acercar">
                        <i class="bi bi-zoom-in"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" onclick="resetearZoom()" title="Resetear">
                        <i class="bi bi-arrows-angle-contract"></i>
                    </button>
                    <span class="vr"></span>
                    <button class="btn btn-sm btn-outline-primary" onclick="maximizarAlto()" title="Maximizar Alto">
                        <i class="bi bi-arrows-expand"></i> Alto
                    </button>
                    <button class="btn btn-sm btn-outline-primary" onclick="maximizarAncho()" title="Maximizar Ancho">
                        <i class="bi bi-arrows-expand-vertical"></i> Ancho
                    </button>
                </div>
            </div>
            <div id="tamano-personalizado" class="mt-2" style="display: none;">
                <div class="input-group input-group-sm">
                    <input type="number" id="ancho-personalizado" class="form-control" placeholder="Ancho (mm)" min="50" max="500" step="1" value="210" onchange="aplicarTamanoPersonalizado()">
                    <span class="input-group-text">×</span>
                    <input type="number" id="alto-personalizado" class="form-control" placeholder="Alto (mm)" min="50" max="800" step="1" value="297" onchange="aplicarTamanoPersonalizado()">
                    <span class="input-group-text">mm</span>
                </div>
            </div>
        </div>
        <div class="canvas-wrapper">
            <div class="ruler-horizontal" id="ruler-horizontal">
                <div class="ruler-scale" id="ruler-scale"></div>
            </div>
            <div class="ruler-vertical" id="ruler-vertical">
                <div class="ruler-scale-vertical" id="ruler-scale-vertical"></div>
            </div>
            <div class="report-canvas" id="report-canvas" data-tamano="A4">
                <div class="canvas-content" id="canvas-content"></div>
                <!-- Los elementos se agregarán aquí mediante drag and drop -->
                <div class="drop-zone" id="canvas-drop-zone">
                    <div class="text-center text-muted py-5">
                        <i class="bi bi-mouse3" style="font-size: 2rem;"></i>
                        <p class="mt-2">Arrastre elementos desde el panel izquierdo</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Properties Panel con Pestañas -->
    <div class="properties-panel">
        <!-- Nav tabs -->
        <ul class="nav nav-tabs mb-3" id="properties-tabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="tab-individual" data-bs-toggle="tab" data-bs-target="#panel-individual" type="button" role="tab">
                    <i class="bi bi-cursor"></i> Elemento
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="tab-global" data-bs-toggle="tab" data-bs-target="#panel-global" type="button" role="tab">
                    <i class="bi bi-sliders"></i> General
                </button>
            </li>
        </ul>
        
        <!-- Tab panes -->
        <div class="tab-content" id="properties-tab-content">
            <!-- Pestaña: Propiedades Individuales -->
            <div class="tab-pane fade show active" id="panel-individual" role="tabpanel">
                <div id="properties-panel">
                    <h6><i class="bi bi-sliders"></i> Propiedades</h6>
                    <p class="text-muted small">Seleccione un elemento para editar sus propiedades</p>
                </div>
            </div>
            
            <!-- Pestaña: Configuración Global -->
            <div class="tab-pane fade" id="panel-global" role="tabpanel">
                <div id="config-secciones-panel">
                    <!-- MÁRGENES DE PÁGINA -->
                    <div class="ribbon-group" style="margin-bottom: 12px; border: 2px solid #007bff; background: #f0f8ff; padding: 6px;">
                        <div class="ribbon-group-title" style="font-size: 0.75rem; font-weight: bold; color: #495057; margin-bottom: 4px;">MÁRGENES DE PÁGINA</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                            <input type="number" id="config-margen-hoja-superior" 
                                   value="{{ configuracion.margenes.get('superior', 20) if configuracion.margenes else 20 }}" 
                                   placeholder="↑" min="0" max="100" step="1" title="Margen Superior (mm)"
                                   onchange="actualizarMargenesHoja()"
                                   style="width: 100%; padding: 3px; font-size: 0.75rem;">
                            <input type="number" id="config-margen-hoja-inferior" 
                                   value="{{ configuracion.margenes.get('inferior', 20) if configuracion.margenes else 20 }}" 
                                   placeholder="↓" min="0" max="100" step="1" title="Margen Inferior (mm)"
                                   onchange="actualizarMargenesHoja()"
                                   style="width: 100%; padding: 3px; font-size: 0.75rem;">
                            <input type="number" id="config-margen-hoja-izquierdo" 
                                   value="{{ configuracion.margenes.get('izquierdo', 20) if configuracion.margenes else 20 }}" 
                                   placeholder="←" min="0" max="100" step="1" title="Margen Izquierdo (mm)"
                                   onchange="actualizarMargenesHoja()"
                                   style="width: 100%; padding: 3px; font-size: 0.75rem;">
                            <input type="number" id="config-margen-hoja-derecho" 
                                   value="{{ configuracion.margenes.get('derecho', 20) if configuracion.margenes else 20 }}" 
                                   placeholder="→" min="0" max="100" step="1" title="Margen Derecho (mm)"
                                   onchange="actualizarMargenesHoja()"
                                   style="width: 100%; padding: 3px; font-size: 0.75rem;">
                        </div>
                    </div>
                    
                    <!-- TÍTULOS -->
                    <div class="ribbon-group" style="margin-bottom: 12px; border: 1px solid #dee2e6; padding: 8px; background: #f8f9fa;">
                        <div class="ribbon-group-title" style="font-size: 0.75rem; font-weight: bold; color: #495057; margin-bottom: 6px;">TÍTULOS</div>
                        
                        <!-- Tamaño y Fuente -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 6px;">
                            <div>
                                <label style="font-size: 0.7rem; color: #6c757d; margin-bottom: 2px; display: block;">Tamaño</label>
                                <input type="number" id="config-tamano-titulo" value="{{ configuracion.secciones.get('titulo_tamano', 14) if configuracion.secciones else 14 }}" 
                                       placeholder="14" min="8" max="72" title="Tamaño (px)"
                                       onchange="actualizarConfigSecciones('titulo_tamano', parseInt(this.value) || 14)"
                                       style="width: 100%; padding: 3px; font-size: 0.75rem;">
                            </div>
                            <div>
                                <label style="font-size: 0.7rem; color: #6c757d; margin-bottom: 2px; display: block;">Fuente</label>
                                <select id="config-fuente-titulo" onchange="actualizarConfigSecciones('titulo_fuente', this.value)"
                                        style="width: 100%; padding: 3px; font-size: 0.75rem;">
                                    <option value="Arial" {{ 'selected' if (configuracion.secciones.get('titulo_fuente', 'Arial') if configuracion.secciones else 'Arial') == 'Arial' else '' }}>Arial</option>
                                    <option value="Times New Roman" {{ 'selected' if (configuracion.secciones.get('titulo_fuente', 'Arial') if configuracion.secciones else 'Arial') == 'Times New Roman' else '' }}>Times</option>
                                    <option value="Helvetica" {{ 'selected' if (configuracion.secciones.get('titulo_fuente', 'Arial') if configuracion.secciones else 'Arial') == 'Helvetica' else '' }}>Helvetica</option>
                                    <option value="Courier New" {{ 'selected' if (configuracion.secciones.get('titulo_fuente', 'Arial') if configuracion.secciones else 'Arial') == 'Courier New' else '' }}>Courier</option>
                                </select>
                            </div>
                        </div>
                        
                        <!-- Fondo y Texto (Colores) -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 6px;">
                            <div>
                                <label style="font-size: 0.7rem; color: #6c757d; margin-bottom: 2px; display: block;">Fondo</label>
                                {% set color_fondo_titulo = configuracion.secciones.get('color_fondo_titulo', '#e3f2fd') if configuracion.secciones else '#e3f2fd' %}
                                {% if color_fondo_titulo|length == 4 %}{% set color_fondo_titulo = '#' + color_fondo_titulo[1] + color_fondo_titulo[1] + color_fondo_titulo[2] + color_fondo_titulo[2] + color_fondo_titulo[3] + color_fondo_titulo[3] %}{% endif %}
                                <input type="color" id="config-color-fondo-titulo" value="{{ color_fondo_titulo }}" 
                                       onchange="actualizarConfigSecciones('color_fondo_titulo', this.value)"
                                       title="Fondo Título"
                                       style="width: 100%; height: 32px; border: 1px solid #ced4da; border-radius: 3px;">
                            </div>
                            <div>
                                <label style="font-size: 0.7rem; color: #6c757d; margin-bottom: 2px; display: block;">Texto</label>
                                {% set titulo_color = configuracion.secciones.get('titulo_color', '#007bff') if configuracion.secciones else '#007bff' %}
                                {% if titulo_color|length == 4 %}{% set titulo_color = '#' + titulo_color[1] + titulo_color[1] + titulo_color[2] + titulo_color[2] + titulo_color[3] + titulo_color[3] %}{% endif %}
                                <input type="color" id="config-color-titulo-texto" value="{{ titulo_color }}" 
                                       onchange="actualizarConfigSecciones('titulo_color', this.value)"
                                       title="Color Texto Título"
                                       style="width: 100%; height: 32px; border: 1px solid #ced4da; border-radius: 3px;">
                            </div>
                        </div>
                        
                        <!-- Alineación -->
                        <div style="margin-bottom: 6px;">
                            <label style="font-size: 0.7rem; color: #6c757d; margin-bottom: 2px; display: block;">Alineación</label>
                            <select id="config-alineacion-titulo" onchange="actualizarConfigSecciones('titulo_alineacion', this.value)"
                                    style="width: 100%; padding: 3px; font-size: 0.75rem;">
                                <option value="left" {{ 'selected' if (configuracion.secciones.get('titulo_alineacion', 'left') if configuracion.secciones else 'left') == 'left' else '' }}>← Izquierda</option>
                                <option value="center" {{ 'selected' if (configuracion.secciones.get('titulo_alineacion', 'left') if configuracion.secciones else 'left') == 'center' else '' }}>Centro</option>
                                <option value="right" {{ 'selected' if (configuracion.secciones.get('titulo_alineacion', 'left') if configuracion.secciones else 'left') == 'right' else '' }}>Derecha →</option>
                            </select>
                        </div>
                        
                        <!-- Negrita y Cursiva -->
                        <div style="display: flex; gap: 6px;">
                            {% set titulo_negrita_activa = (configuracion.secciones.get('titulo_negrita', False) if configuracion.secciones else False) %}
                            {% set titulo_cursiva_activa = (configuracion.secciones.get('titulo_cursiva', False) if configuracion.secciones else False) %}
                            <button type="button" id="btn-titulo-negrita" onclick="toggleBotonFormato('config-titulo-negrita')"
                                    class="btn btn-sm {{ 'btn-primary' if titulo_negrita_activa else 'btn-outline-secondary' }}"
                                    style="flex: 1; font-size: 0.75rem; padding: 3px;">
                                <strong>N</strong>
                            </button>
                            <button type="button" id="btn-titulo-cursiva" onclick="toggleBotonFormato('config-titulo-cursiva')"
                                    class="btn btn-sm {{ 'btn-primary' if titulo_cursiva_activa else 'btn-outline-secondary' }}"
                                    style="flex: 1; font-size: 0.75rem; padding: 3px;">
                                <em>K</em>
                            </button>
                            <input type="checkbox" id="config-titulo-negrita" {{ 'checked' if titulo_negrita_activa else '' }} 
                                   onchange="manejarCambioFormato(this, 'titulo_negrita', 'btn-titulo-negrita')"
                                   style="display: none;">
                            <input type="checkbox" id="config-titulo-cursiva" {{ 'checked' if titulo_cursiva_activa else '' }} 
                                   onchange="manejarCambioFormato(this, 'titulo_cursiva', 'btn-titulo-cursiva')"
                                   style="display: none;">
                        </div>
                    </div>
                    
                    <!-- CONTENIDO -->
                    <div class="ribbon-group" style="margin-bottom: 6px; border: 1px solid #dee2e6; padding: 8px; background: #fff;">
                        <div class="ribbon-group-title" style="font-size: 0.75rem; font-weight: bold; color: #495057; margin-bottom: 6px;">CONTENIDO</div>
                        
                        <!-- Tamaño y Fuente -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 6px;">
                            <div>
                                <label style="font-size: 0.7rem; color: #6c757d; margin-bottom: 2px; display: block;">Tamaño</label>
                                <input type="number" id="config-tamano-contenido" value="{{ configuracion.secciones.get('contenido_tamano', 12) if configuracion.secciones else 12 }}" 
                                       placeholder="12" min="8" max="24" title="Tamaño (px)"
                                       onchange="actualizarConfigSecciones('contenido_tamano', parseInt(this.value) || 12)"
                                       style="width: 100%; padding: 3px; font-size: 0.75rem;">
                            </div>
                            <div>
                                <label style="font-size: 0.7rem; color: #6c757d; margin-bottom: 2px; display: block;">Fuente</label>
                                <select id="config-fuente-contenido" onchange="actualizarConfigSecciones('contenido_fuente', this.value)"
                                        style="width: 100%; padding: 3px; font-size: 0.75rem;">
                                    <option value="Arial" {{ 'selected' if (configuracion.secciones.get('contenido_fuente', 'Arial') if configuracion.secciones else 'Arial') == 'Arial' else '' }}>Arial</option>
                                    <option value="Times New Roman" {{ 'selected' if (configuracion.secciones.get('contenido_fuente', 'Arial') if configuracion.secciones else 'Arial') == 'Times New Roman' else '' }}>Times</option>
                                    <option value="Helvetica" {{ 'selected' if (configuracion.secciones.get('contenido_fuente', 'Arial') if configuracion.secciones else 'Arial') == 'Helvetica' else '' }}>Helvetica</option>
                                </select>
                            </div>
                        </div>
                        
                        <!-- Texto (Color) -->
                        <div style="margin-bottom: 6px;">
                            <label style="font-size: 0.7rem; color: #6c757d; margin-bottom: 2px; display: block;">Texto</label>
                            {% set contenido_color = configuracion.secciones.get('contenido_color', '#333333') if configuracion.secciones else '#333333' %}
                            {% if contenido_color|length == 4 %}{% set contenido_color = '#' + contenido_color[1] + contenido_color[1] + contenido_color[2] + contenido_color[2] + contenido_color[3] + contenido_color[3] %}{% endif %}
                            <input type="color" id="config-color-contenido" value="{{ contenido_color }}" 
                                   onchange="actualizarConfigSecciones('contenido_color', this.value)"
                                   title="Color Texto"
                                   style="width: 100%; height: 32px; border: 1px solid #ced4da; border-radius: 3px;">
                        </div>
                        
                        <!-- Alineación -->
                        <div style="margin-bottom: 6px;">
                            <label style="font-size: 0.7rem; color: #6c757d; margin-bottom: 2px; display: block;">Alineación</label>
                            <select id="config-alineacion-contenido" onchange="actualizarConfigSecciones('alineacion_contenido', this.value)"
                                    style="width: 100%; padding: 3px; font-size: 0.75rem;">
                                <option value="left" {{ 'selected' if (configuracion.secciones.get('alineacion_contenido', 'left') if configuracion.secciones else 'left') == 'left' else '' }}>← Izquierda</option>
                                <option value="center" {{ 'selected' if (configuracion.secciones.get('alineacion_contenido', 'left') if configuracion.secciones else 'left') == 'center' else '' }}>Centro</option>
                                <option value="right" {{ 'selected' if (configuracion.secciones.get('alineacion_contenido', 'left') if configuracion.secciones else 'left') == 'right' else '' }}>Derecha →</option>
                            </select>
                        </div>
                        
                        <!-- Indentación y Viñetas -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 6px;">
                            <div>
                                <label style="font-size: 0.7rem; color: #6c757d; margin-bottom: 2px; display: block;">Indentación</label>
                                <input type="number" id="config-indentacion" value="{{ configuracion.secciones.get('indentacion', 15) if configuracion.secciones else 15 }}" 
                                       placeholder="15" min="0" max="100" title="Indentación (px)"
                                       onchange="actualizarConfigSecciones('indentacion', parseInt(this.value) || 0)"
                                       style="width: 100%; padding: 3px; font-size: 0.75rem;">
                            </div>
                            <div>
                                <label style="font-size: 0.7rem; color: #6c757d; margin-bottom: 2px; display: block;">Viñetas</label>
                                <div style="display: flex; align-items: center; gap: 4px;">
                                    <input type="checkbox" id="config-mostrar-vinetas" {{ 'checked' if (configuracion.secciones.get('mostrar_vinetas', True) if configuracion.secciones else True) else '' }} 
                                           onchange="actualizarConfigSecciones('mostrar_vinetas', this.checked)"
                                           title="Viñetas"
                                           style="width: auto;">
                                    {% set color_vineta = configuracion.secciones.get('color_vineta', '#007bff') if configuracion.secciones else '#007bff' %}
                                    {% if color_vineta|length == 4 %}{% set color_vineta = '#' + color_vineta[1] + color_vineta[1] + color_vineta[2] + color_vineta[2] + color_vineta[3] + color_vineta[3] %}{% endif %}
                                    <input type="color" id="config-color-vineta" value="{{ color_vineta }}" 
                                           onchange="actualizarConfigSecciones('color_vineta', this.value)"
                                           title="Color Viñeta"
                                           style="flex: 1; height: 28px; border: 1px solid #ced4da; border-radius: 3px;">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Negrita y Cursiva -->
                        <div style="display: flex; gap: 6px;">
                            {% set negrita_activa = (configuracion.secciones.get('contenido_negrita', False) if configuracion.secciones else False) %}
                            {% set cursiva_activa = (configuracion.secciones.get('contenido_cursiva', False) if configuracion.secciones else False) %}
                            <button type="button" id="btn-contenido-negrita" onclick="toggleBotonFormato('config-contenido-negrita')"
                                    class="btn btn-sm {{ 'btn-primary' if negrita_activa else 'btn-outline-secondary' }}"
                                    style="flex: 1; font-size: 0.75rem; padding: 3px;">
                                <strong>N</strong>
                            </button>
                            <button type="button" id="btn-contenido-cursiva" onclick="toggleBotonFormato('config-contenido-cursiva')"
                                    class="btn btn-sm {{ 'btn-primary' if cursiva_activa else 'btn-outline-secondary' }}"
                                    style="flex: 1; font-size: 0.75rem; padding: 3px;">
                                <em>K</em>
                            </button>
                            <input type="checkbox" id="config-contenido-negrita" {{ 'checked' if negrita_activa else '' }} 
                                   onchange="manejarCambioFormato(this, 'contenido_negrita', 'btn-contenido-negrita')"
                                   style="display: none;">
                            <input type="checkbox" id="config-contenido-cursiva" {{ 'checked' if cursiva_activa else '' }} 
                                   onchange="manejarCambioFormato(this, 'contenido_cursiva', 'btn-contenido-cursiva')"
                                   style="display: none;">
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<button class="btn btn-primary btn-save" onclick="mostrarModalGuardar()">
    <i class="bi bi-save"></i> Guardar Diseño
</button>

<!-- Modal para guardar diseño -->
<div class="modal fade" id="modalGuardar" tabindex="-1" aria-labelledby="modalGuardarLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="modalGuardarLabel">
                    <i class="bi bi-save"></i> Guardar Diseño
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="nombre-disenio" class="form-label">Nombre del Diseño <span class="text-danger">*</span></label>
                    <input type="text" class="form-control" id="nombre-disenio" 
                           value="{{ disenio.nombre if disenio.nombre != 'Nuevo Diseño' else '' }}" 
                           placeholder="Ej: Papel Común, Membretado, etc." required>
                    <small class="form-text text-muted">Ingrese un nombre descriptivo para este diseño</small>
                </div>
                <div class="mb-3">
                    <label for="tipo-estudio" class="form-label">Tipo de Estudio <span class="text-danger">*</span></label>
                    <select class="form-select" id="tipo-estudio" required>
                        <option value="PAP" {{ 'selected' if (disenio.tipo_estudio if disenio else 'PAP') == 'PAP' else '' }}>PAP - Papanicolaou</option>
                        <option value="BIOPSIA" {{ 'selected' if (disenio.tipo_estudio if disenio else '') == 'BIOPSIA' else '' }}>BIOPSIA</option>
                        <option value="CITOLOGÍA" {{ 'selected' if (disenio.tipo_estudio if disenio else '') == 'CITOLOGÍA' else '' }}>CITOLOGÍA</option>
                    </select>
                    <small class="form-text text-muted">Seleccione el tipo de estudio para el cual es este diseño</small>
                </div>
                <div class="mb-3">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="es-default" 
                               {{ 'checked' if (disenio.es_default if disenio else False) else '' }}>
                        <label class="form-check-label" for="es-default">
                            Marcar como diseño predeterminado para este tipo de estudio
                        </label>
                        <small class="form-text text-muted d-block">Si está marcado, este diseño se usará por defecto al generar informes de este tipo</small>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                <button type="button" class="btn btn-primary" onclick="guardarEstructura()">
                    <i class="bi bi-save"></i> Guardar
                </button>
            </div>
        </div>
    </div>
</div>

<script>
// Asegurar que estructura siempre sea un array
let estructuraRaw = {{ configuracion.get('estructura_visual', [])|tojson if configuracion.get('estructura_visual') else '[]'|tojson }};
let estructura = Array.isArray(estructuraRaw) ? estructuraRaw : [];
console.log('Estructura cargada desde servidor:', JSON.stringify(estructura, null, 2));
console.log('Elementos por tipo al cargar:', estructura.reduce((acc, el) => {
    acc[el.tipo] = (acc[el.tipo] || 0) + 1;
    return acc;
}, {}));
const elementosDatosCargados = estructura.filter(el => ['protocolo-fecha', 'datos-paciente', 'datos-medico', 'datos-paciente-medico'].includes(el.tipo));
console.log('Elementos de datos cargados:', elementosDatosCargados.length, elementosDatosCargados.map(el => ({ tipo: el.tipo, id: el.id, contenido: el.contenido })));
let elementoSeleccionado = null;
let elementoIdCounter = 0;
// Inicializar contador basado en elementos existentes
if (estructura.length > 0) {
    const maxId = Math.max(...estructura.map(el => {
        const match = el.id.match(/\d+$/);
        return match ? parseInt(match[0]) : 0;
    }));
    elementoIdCounter = maxId;
}
let zoomLevel = 100;
let disenioId = {{ disenio.disenio_id if disenio.disenio_id else 0 }};
let tipoEstudioActual = '{{ disenio.tipo_estudio if disenio.tipo_estudio else "PAP" }}';
let tipoEstudioInicial = '{{ disenio.tipo_estudio if disenio.tipo_estudio else "PAP" }}';

// Mapeo de secciones válidas por tipo de estudio
const seccionesPorTipo = {
    'PAP': ['DATOS_CLINICOS', 'EXTENDIDO', 'CELULAS_CONFORMACION', 'CELULAS_JUNTO_A', 'COMP_INFLAMATORIO', 'FLORA', 'DIAGNOSTICO'],
    'BIOPSIA': ['MATERIAL_REMITIDO', 'DESCRIPCION_MACROSCOPICA', 'DESCRIPCION_MICROSCOPICA', 'DIAGNOSTICO'],
    'CITOLOGÍA': ['MATERIAL_REMITIDO', 'DESCRIPCION_MICROSCOPICA', 'DIAGNOSTICO']
};

// Mapeo de conversión entre tipos (cuando se convierte un diseño)
const mapeoConversiones = {
    'PAP->BIOPSIA': {
        'DATOS_CLINICOS': null, // Eliminar
        'EXTENDIDO': null,
        'CELULAS_CONFORMACION': 'DESCRIPCION_MICROSCOPICA',
        'CELULAS_JUNTO_A': null,
        'COMP_INFLAMATORIO': null,
        'FLORA': null,
        'DIAGNOSTICO': 'DIAGNOSTICO'
    },
    'BIOPSIA->PAP': {
        'MATERIAL_REMITIDO': null,
        'DESCRIPCION_MACROSCOPICA': null,
        'DESCRIPCION_MICROSCOPICA': 'CELULAS_CONFORMACION',
        'DIAGNOSTICO': 'DIAGNOSTICO'
    },
    'BIOPSIA->CITOLOGÍA': {
        'MATERIAL_REMITIDO': 'MATERIAL_REMITIDO',
        'DESCRIPCION_MACROSCOPICA': null,
        'DESCRIPCION_MICROSCOPICA': 'DESCRIPCION_MICROSCOPICA',
        'DIAGNOSTICO': 'DIAGNOSTICO'
    },
    'CITOLOGÍA->BIOPSIA': {
        'MATERIAL_REMITIDO': 'MATERIAL_REMITIDO',
        'DESCRIPCION_MICROSCOPICA': 'DESCRIPCION_MICROSCOPICA',
        'DIAGNOSTICO': 'DIAGNOSTICO'
    },
    'PAP->CITOLOGÍA': {
        'DATOS_CLINICOS': null,
        'EXTENDIDO': null,
        'CELULAS_CONFORMACION': 'DESCRIPCION_MICROSCOPICA',
        'CELULAS_JUNTO_A': null,
        'COMP_INFLAMATORIO': null,
        'FLORA': null,
        'DIAGNOSTICO': 'DIAGNOSTICO'
    },
    'CITOLOGÍA->PAP': {
        'MATERIAL_REMITIDO': null,
        'DESCRIPCION_MICROSCOPICA': 'CELULAS_CONFORMACION',
        'DIAGNOSTICO': 'DIAGNOSTICO'
    }
};

// Definición de secciones para el toolbox
const seccionesToolbox = {
    'DATOS_CLINICOS': {
        nombre: 'DATOS CLÍNICOS',
        descripcion: 'Datos clínicos del paciente',
        icono: 'bi-folder'
    },
    'EXTENDIDO': {
        nombre: 'EXTENDIDO',
        descripcion: 'Descripción del extendido',
        icono: 'bi-folder'
    },
    'CELULAS_CONFORMACION': {
        nombre: 'DESCRIPCIÓN CITOLÓGICA',
        descripcion: 'Conformación celular',
        icono: 'bi-folder'
    },
    'CELULAS_JUNTO_A': {
        nombre: 'JUNTO A',
        descripcion: 'Células junto a',
        icono: 'bi-folder'
    },
    'COMP_INFLAMATORIO': {
        nombre: 'COMPONENTE INFLAMATORIO',
        descripcion: 'Componente inflamatorio',
        icono: 'bi-folder'
    },
    'FLORA': {
        nombre: 'FLORA',
        descripcion: 'Flora',
        icono: 'bi-folder'
    },
    'MATERIAL_REMITIDO': {
        nombre: 'MATERIAL REMITIDO',
        descripcion: 'Material remitido',
        icono: 'bi-folder'
    },
    'DESCRIPCION_MACROSCOPICA': {
        nombre: 'DESCRIPCIÓN MACROSCÓPICA',
        descripcion: 'Descripción macroscópica',
        icono: 'bi-folder'
    },
    'DESCRIPCION_MICROSCOPICA': {
        nombre: 'DESCRIPCIÓN MICROSCÓPICA',
        descripcion: 'Descripción microscópica',
        icono: 'bi-folder'
    },
    'DIAGNOSTICO': {
        nombre: 'DIAGNÓSTICO',
        descripcion: 'Diagnóstico',
        icono: 'bi-folder'
    }
};

function actualizarToolboxSecciones() {
    // Actualizar el toolbox según el tipo de estudio actual
    const toolboxSecciones = document.getElementById('toolbox-secciones');
    if (!toolboxSecciones) return;
    
    // Limpiar secciones anteriores
    toolboxSecciones.innerHTML = '';
    
    // Obtener secciones válidas para el tipo actual
    const seccionesValidas = seccionesPorTipo[tipoEstudioActual] || [];
    
    // Crear elementos del toolbox para cada sección válida
    seccionesValidas.forEach(codigo => {
        const seccion = seccionesToolbox[codigo];
        if (seccion) {
            const div = document.createElement('div');
            div.className = 'toolbox-item';
            div.draggable = true;
            div.setAttribute('data-type', 'seccion');
            div.setAttribute('data-seccion', codigo);
            div.innerHTML = `
                <i class="bi ${seccion.icono}"></i> <strong>Sección: ${seccion.nombre}</strong>
                <div class="small text-muted">${seccion.descripcion}</div>
            `;
            toolboxSecciones.appendChild(div);
        }
    });
    
    // Re-inicializar drag and drop para los nuevos elementos
    inicializarDragAndDrop();
    
    console.log(`Toolbox actualizado para tipo: ${tipoEstudioActual}, secciones: ${seccionesValidas.join(', ')}`);
}

// Normalizar estructura: asegurar que los elementos de tipo 'logo' tengan su contenido HTML correcto
estructura = estructura.map(e => {
    if (e && e.tipo === 'logo') {
        // Si el logo no tiene contenido o no tiene HTML de imagen, agregarlo
        if (!e.contenido || (typeof e.contenido === 'string' && !e.contenido.includes('<img'))) {
            e.contenido = '<img src="/static/img/logo.png">';
        }
        // Asegurar que el contenido sea un string válido
        if (typeof e.contenido !== 'string') {
            e.contenido = '<img src="/static/img/logo.png">';
        }
    }
    return e;
});

// Inicializar elementos existentes
document.addEventListener('DOMContentLoaded', function() {
    // Cargar toolbox inicial según tipo de estudio
    actualizarToolboxSecciones();
    
    // Normalizar colores en inputs de color al cargar
    const colorInputs = document.querySelectorAll('input[type="color"]');
    colorInputs.forEach(input => {
        if (input.value && input.value.length === 4) {
            // Expandir formato corto a completo
            const expanded = '#' + input.value[1] + input.value[1] + input.value[2] + input.value[2] + input.value[3] + input.value[3];
            input.value = expanded;
        }
    });
    
    inicializarDragAndDrop();
    cargarEstructuraExistente();
    
    // Inicializar tamaño de papel desde configuración
    const config = {{ configuracion|tojson }};
    if (config && config.impresion && config.impresion.tamaño_papel) {
        const selector = document.getElementById('tamano-papel');
        if (selector) {
            selector.value = config.impresion.tamaño_papel;
            cambiarTamanoPapel(config.impresion.tamaño_papel);
            
            // Si es personalizado, cargar dimensiones
            if (config.impresion.tamaño_papel === 'personalizado' && config.impresion.dimensiones_personalizadas) {
                document.getElementById('ancho-personalizado').value = config.impresion.dimensiones_personalizadas.ancho || 210;
                document.getElementById('alto-personalizado').value = config.impresion.dimensiones_personalizadas.alto || 297;
                aplicarTamanoPersonalizado();
            }
        }
    }
    
    // Inicializar zoom por defecto (más pequeño para ver mejor)
    zoomLevel = 50;
    aplicarZoom();
    
    // Sincronizar estado visual de botones de formato global
    inicializarBotonesFormatoGlobal();
    
    // Dibujar márgenes después de que todo esté cargado
    setTimeout(() => {
        dibujarMargenes();
        actualizarRegla();
        actualizarReglaVertical();
    }, 500);
    
    // Actualizar regla cuando se redimensiona la ventana
    let resizeTimeout;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            actualizarRegla();
            actualizarReglaVertical();
        }, 100);
    });
});

function inicializarDragAndDrop() {
    // Hacer elementos del toolbox arrastrables
    document.querySelectorAll('.toolbox-item').forEach(item => {
        item.addEventListener('dragstart', handleDragStart);
        item.addEventListener('dragend', handleDragEnd);
    });
    
    // Configurar zona de drop - usar el canvas y la drop-zone
    const canvas = document.getElementById('report-canvas');
    const dropZone = document.getElementById('canvas-drop-zone');
    
    // Prevenir comportamiento por defecto en el canvas
    canvas.addEventListener('dragover', handleDragOver);
    canvas.addEventListener('drop', handleDrop);
    canvas.addEventListener('dragleave', handleDragLeave);
    
    // También configurar en la drop-zone si existe
    if (dropZone) {
        dropZone.addEventListener('dragover', handleDragOver);
        dropZone.addEventListener('drop', handleDrop);
        dropZone.addEventListener('dragleave', handleDragLeave);
    }
}

function handleDragStart(e) {
    // Si el arrastre viene de un elemento del toolbox
    const item = e.target.closest('.toolbox-item');
    if (item) {
        const tipo = item.dataset.type;
        const seccion = item.dataset.seccion; // Si es una sección, obtener el código
        if (tipo) {
            e.dataTransfer.setData('text/plain', tipo);
            e.dataTransfer.setData('seccion', seccion || ''); // Guardar también el tipo de sección
            e.dataTransfer.effectAllowed = 'copy';
            item.classList.add('dragging');
            console.log('Drag start - tipo:', tipo, 'seccion:', seccion); // Debug
        }
    }
}

function handleDragEnd(e) {
    const item = e.target.closest('.toolbox-item');
    if (item) {
        item.classList.remove('dragging');
    }
}

function handleDragOver(e) {
    e.preventDefault();
    e.stopPropagation();
    const dropZone = e.target.closest('.drop-zone') || e.target.closest('#report-canvas');
    if (dropZone) {
        dropZone.classList.add('drag-over');
    }
}

function handleDragLeave(e) {
    e.preventDefault();
    const dropZone = e.target.closest('.drop-zone') || e.target.closest('#report-canvas');
    if (dropZone && !dropZone.contains(e.relatedTarget)) {
        dropZone.classList.remove('drag-over');
    }
}

function handleDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const canvas = document.getElementById('report-canvas');
    const dropZone = document.getElementById('canvas-drop-zone');
    
    // Limpiar indicadores visuales
    if (dropZone) {
        dropZone.classList.remove('drag-over');
    }
    canvas.classList.remove('drag-over');
    
    // Obtener tipo de elemento arrastrado y tipo de sección si existe
    const tipo = e.dataTransfer.getData('text/plain');
    const seccion = e.dataTransfer.getData('seccion');
    
    console.log('Drop event - tipo:', tipo, 'seccion:', seccion); // Debug
    
    if (tipo && tipo.trim() !== '') {
        // Si todavía hay el mensaje inicial, limpiarlo
        if (dropZone && dropZone.querySelector('.text-center')) {
            dropZone.remove();
        }
        
        crearElemento(tipo, seccion);
    } else {
        console.error('No se pudo obtener el tipo del elemento arrastrado');
    }
    
    return false;
}

function crearElemento(tipo, seccionCodigo = null) {
    // Asegurar que estructura sea un array
    if (!Array.isArray(estructura)) {
        estructura = [];
    }
    
    elementoIdCounter++;
    const id = `element-${elementoIdCounter}`;
    
    // Mapeo de códigos de sección a nombres
    const mapeoSecciones = {
        'DATOS_CLINICOS': 'DATOS CLÍNICOS',
        'MATERIAL_REMITIDO': 'MATERIAL REMITIDO',
        'DESCRIPCION_MACROSCOPICA': 'DESCRIPCIÓN MACROSCÓPICA',
        'DESCRIPCION_MICROSCOPICA': 'DESCRIPCIÓN MICROSCÓPICA',
        'DIAGNOSTICO': 'DIAGNÓSTICO',
        'EXTENDIDO': 'EXTENDIDO',
        'CELULAS_CONFORMACION': 'DESCRIPCIÓN CITOLÓGICA',
        'CELULAS_JUNTO_A': 'Junto a',
        'COMP_INFLAMATORIO': 'COMPONENTE INFLAMATORIO',
        'FLORA': 'Flora'
    };
    
    // Si es una sección y tiene código, usar el nombre correspondiente
    let contenido = getContenidoDefault(tipo);
    if (tipo === 'seccion' && seccionCodigo && mapeoSecciones[seccionCodigo]) {
        contenido = mapeoSecciones[seccionCodigo];
    }
    
    const elemento = {
        id: id,
        tipo: tipo,
        contenido: contenido,
        propiedades: getPropiedadesDefault(tipo),
        orden: estructura.length,
        seccion_codigo: seccionCodigo || null // Guardar el código de sección para referencia
    };
    
    // Si es una sección y no tiene código, intentar deducirlo del contenido
    if (tipo === 'seccion' && !elemento.seccion_codigo) {
        const contenidoUpper = contenido.toUpperCase();
        const mapeoInverso = {
            'DATOS CLÍNICOS': 'DATOS_CLINICOS',
            'MATERIAL REMITIDO': 'MATERIAL_REMITIDO',
            'DESCRIPCIÓN MACROSCÓPICA': 'DESCRIPCION_MACROSCOPICA',
            'DESCRIPCIÓN MICROSCÓPICA': 'DESCRIPCION_MICROSCOPICA',
            'DESCRIPCIÓN CITOLÓGICA': 'DESCRIPCION_MICROSCOPICA',
            'DIAGNÓSTICO': 'DIAGNOSTICO',
            'EXTENDIDO': 'EXTENDIDO',
            'JUNTO A': 'CELULAS_JUNTO_A',
            'COMPONENTE INFLAMATORIO': 'COMP_INFLAMATORIO',
            'FLORA': 'FLORA'
        };
        for (const [nombre, codigo] of Object.entries(mapeoInverso)) {
            if (contenidoUpper.includes(nombre.toUpperCase()) || nombre.toUpperCase().includes(contenidoUpper)) {
                elemento.seccion_codigo = codigo;
                console.log(`Código de sección deducido para "${contenido}": ${codigo}`);
                break;
            }
        }
    }
    
    estructura.push(elemento);
    renderizarElemento(elemento);
    seleccionarElemento(id);
    console.log('Elemento creado:', elemento, 'Total elementos:', estructura.length);
}

function getContenidoDefault(tipo) {
    const defaults = {
        'logo': '<img src="/static/img/logo.png">',
        'texto-laboratorio': '{{ configuracion.header.get("laboratorio_nombre", "LABORATORIO DE DIAGNÓSTICO HISTOPATOLÓGICO") }}',
        'titulo': '{{ titulo_reporte }}',
        'subtitulo': '{{ subtitulo_reporte }}',
        'separador': '<hr>',
        'protocolo-fecha': 'PROTOCOLO Y FECHA',
        'datos-paciente': 'DATOS DEL PACIENTE',
        'datos-medico': 'DATOS DEL MÉDICO',
        'datos-paciente-medico': 'DATOS DEL PACIENTE Y MÉDICO',
        'texto-libre': 'Texto editable aquí',
        'seccion': 'DATOS CLÍNICOS',
        'espacio': '<div style="height: 20px;"></div>'
    };
    return defaults[tipo] || '';
}

function getPropiedadesDefault(tipo) {
    const propsBase = {
        fuente: 'Arial',
        tamaño: tipo === 'titulo' ? 18 : tipo === 'subtitulo' ? 14 : tipo === 'seccion' ? 14 : (['protocolo-fecha', 'datos-paciente', 'datos-medico', 'datos-paciente-medico'].includes(tipo) ? 14 : 12),
        color: tipo === 'titulo' ? '#333333' : tipo === 'subtitulo' ? '#666666' : tipo === 'seccion' ? '#007bff' : (['protocolo-fecha', 'datos-paciente', 'datos-medico', 'datos-paciente-medico'].includes(tipo) ? '#007bff' : '#000000'),
        alineacion: 'left',
        negrita: tipo === 'titulo' || tipo === 'seccion' || ['protocolo-fecha', 'datos-paciente', 'datos-medico', 'datos-paciente-medico'].includes(tipo),
        cursiva: false,
        margen_superior: 0,
        margen_inferior: 10,
        margen_izquierdo: 0,
        margen_derecho: 0,
        ancho: null,
        alto: null,
        ancho_unit: 'px',
        alto_unit: 'px',
        posicion: 'relative',
        top: null,
        left: null,
        mostrar: true
    };
    
    // Propiedades específicas para secciones
    if (tipo === 'seccion') {
        propsBase.color_fondo = '#e3f2fd';
        propsBase.padding = '8px 12px';
        propsBase.borde_izquierdo = 0; // Por defecto sin borde, se puede agregar si se desea
    }
    
    // Propiedades específicas para elementos de datos
    if (['protocolo-fecha', 'datos-paciente', 'datos-medico', 'datos-paciente-medico'].includes(tipo)) {
        propsBase.color_fondo = '#e3f2fd';
        propsBase.mostrar_titulo = true;
        propsBase.mostrar_borde = false; // Por defecto sin borde
        propsBase.contenido_fuente = 'Arial';
        propsBase.contenido_tamano = 12;
        propsBase.contenido_color = '#333333';
    }
    
    return propsBase;
}

function renderizarElemento(elemento) {
    const canvas = document.getElementById('report-canvas');
    const canvasContent = document.getElementById('canvas-content');
    const dropZone = document.querySelector('#canvas-drop-zone');
    
    // Si todavía existe el mensaje inicial, eliminarlo
    if (dropZone) {
        if (dropZone.querySelector('.text-center')) {
            dropZone.remove();
        } else if (dropZone.classList.contains('drop-zone')) {
            dropZone.classList.remove('drop-zone');
        }
    }
    
    const div = document.createElement('div');
    div.id = elemento.id;
    div.className = 'element-item' + (elemento.tipo === 'logo' ? ' element-logo' : '');
    div.draggable = true;
    
    // Variable para almacenar los valores calculados del título (para usar después del re-renderizado)
    let valoresTituloCalculados = null;
    
    // Si es una sección, renderizar con contenido de ejemplo
    if (elemento.tipo === 'seccion') {
        const props = elemento.propiedades;
        // Usar la configuración global de secciones
        // Obtener configuración global actualizada (siempre usar la referencia más reciente)
        // Forzar actualización desde window.configSecciones que se actualiza en tiempo real
        const configGlobal = window.configSecciones || {};
        
        // El color de fondo debe venir de props.color_fondo primero, si no existe usar configGlobal, si no existe usar default
        // Color de fondo: usar configGlobal si no hay valor personalizado en props
        const DEFAULT_COLOR_FONDO = '#e3f2fd';
        const tieneColorFondoPersonalizado = props.hasOwnProperty('color_fondo') && props.color_fondo !== null && props.color_fondo !== '' && props.color_fondo !== DEFAULT_COLOR_FONDO;
        const colorFondo = tieneColorFondoPersonalizado ? props.color_fondo : (configGlobal.color_fondo_titulo || DEFAULT_COLOR_FONDO);
        
        // Obtener propiedades del título desde props o configuración global
        // ESTRATEGIA: Usar configGlobal SIEMPRE a menos que props tenga un valor explícitamente establecido
        // Para distinguir valores por defecto de valores establecidos, verificamos si props tiene estas propiedades
        // pero si son iguales a los valores por defecto del sistema, usamos configGlobal
        
        // Para que la configuración global funcione, debemos ignorar los valores por defecto del sistema
        // Si props tiene valores que son iguales a los defaults, usar configGlobal en su lugar
        const DEFAULT_FUENTE = 'Arial';
        const DEFAULT_TAMANO = 14;
        const DEFAULT_NEGRITA = true; // Para secciones, el default es true
        const DEFAULT_CURSIVA = false;
        const DEFAULT_ALINEACION = 'left';
        const DEFAULT_COLOR = '#007bff';
        
        // Verificar si props tiene valores personalizados (diferentes de los defaults)
        const tieneFuentePersonalizada = props.hasOwnProperty('fuente') && props.fuente !== null && props.fuente !== '' && props.fuente !== DEFAULT_FUENTE;
        const tieneTamanoPersonalizado = props.hasOwnProperty('tamaño') && props.tamaño !== null && props.tamaño !== 0 && props.tamaño !== DEFAULT_TAMANO;
        const tieneNegritaPersonalizada = props.hasOwnProperty('negrita') && props.negrita !== null && props.negrita !== DEFAULT_NEGRITA;
        const tieneCursivaPersonalizada = props.hasOwnProperty('cursiva') && props.cursiva !== null && props.cursiva !== DEFAULT_CURSIVA;
        const tieneAlineacionPersonalizada = props.hasOwnProperty('alineacion') && props.alineacion !== null && props.alineacion !== '' && props.alineacion !== DEFAULT_ALINEACION;
        const tieneColorPersonalizado = props.hasOwnProperty('color') && props.color !== null && props.color !== '' && props.color !== DEFAULT_COLOR;
        
        // Usar configGlobal SIEMPRE a menos que haya un valor personalizado en props
        const tituloFuente = tieneFuentePersonalizada ? props.fuente : (configGlobal.titulo_fuente || DEFAULT_FUENTE);
        const tituloTamano = tieneTamanoPersonalizado ? props.tamaño : (configGlobal.titulo_tamano || DEFAULT_TAMANO);
        const tituloNegrita = tieneNegritaPersonalizada ? props.negrita : (configGlobal.titulo_negrita !== undefined ? configGlobal.titulo_negrita : DEFAULT_NEGRITA);
        const tituloCursiva = tieneCursivaPersonalizada ? props.cursiva : (configGlobal.titulo_cursiva !== undefined ? configGlobal.titulo_cursiva : DEFAULT_CURSIVA);
        const tituloAlineacion = tieneAlineacionPersonalizada ? props.alineacion : (configGlobal.titulo_alineacion || DEFAULT_ALINEACION);
        const colorTexto = tieneColorPersonalizado ? props.color : (configGlobal.titulo_color || DEFAULT_COLOR);
        
        // Almacenar valores calculados para uso posterior
        valoresTituloCalculados = {
            fuente: tituloFuente,
            tamano: tituloTamano,
            negrita: tituloNegrita,
            cursiva: tituloCursiva,
            alineacion: tituloAlineacion,
            color: colorTexto,
            fondo: colorFondo
        };
        
        // Debug expandido
        console.log('renderizarElemento - Sección:', elemento.contenido);
        console.log('  Valores calculados:', JSON.stringify(valoresTituloCalculados));
        console.log('  tieneFuentePersonalizada:', tieneFuentePersonalizada, 'props.fuente:', props.fuente, 'configGlobal.titulo_fuente:', configGlobal.titulo_fuente, '-> tituloFuente:', tituloFuente);
        console.log('  tieneTamanoPersonalizado:', tieneTamanoPersonalizado, 'props.tamaño:', props.tamaño, 'configGlobal.titulo_tamano:', configGlobal.titulo_tamano, '-> tituloTamano:', tituloTamano);
        console.log('  tieneNegritaPersonalizada:', tieneNegritaPersonalizada, 'props.negrita:', props.negrita, 'configGlobal.titulo_negrita:', configGlobal.titulo_negrita, '-> tituloNegrita:', tituloNegrita);
        console.log('  tieneColorPersonalizado:', tieneColorPersonalizado, 'props.color:', props.color, 'configGlobal.titulo_color:', configGlobal.titulo_color, '-> colorTexto:', colorTexto);
        const padding = props.padding || '8px 12px';
        const bordeIzq = props.borde_izquierdo !== undefined && props.borde_izquierdo !== null ? props.borde_izquierdo : 0;
        const indentacion = props.indentacion !== undefined ? props.indentacion : (configGlobal.indentacion || 15);
        const mostrarVinetas = props.mostrar_vinetas !== undefined ? props.mostrar_vinetas : (configGlobal.mostrar_vinetas !== false);
        const colorVineta = props.color_vineta || configGlobal.color_vineta || '#007bff';
        const contenidoFuente = props.contenido_fuente || configGlobal.contenido_fuente || 'Arial';
        const contenidoTamano = props.contenido_tamano !== undefined ? props.contenido_tamano : (configGlobal.contenido_tamano || 12);
        const contenidoColor = props.contenido_color || configGlobal.contenido_color || '#333333';
        const contenidoNegrita = props.contenido_negrita !== undefined ? props.contenido_negrita : (configGlobal.contenido_negrita || false);
        const contenidoCursiva = props.contenido_cursiva !== undefined ? props.contenido_cursiva : (configGlobal.contenido_cursiva || false);
        const alineacion = props.alineacion_contenido || configGlobal.alineacion_contenido || 'left';
        
        // Contenido de ejemplo para la sección
        const lineasEjemplo = [
            'Primera línea de contenido de ejemplo',
            'Segunda línea de contenido de ejemplo',
            'Tercera línea de contenido de ejemplo'
        ];
        
        const contenidoEjemplo = lineasEjemplo.map((linea, idx) => {
            const estiloLinea = `font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-weight: ${contenidoNegrita ? 'bold' : 'normal'}; font-style: ${contenidoCursiva ? 'italic' : 'normal'}; text-align: ${alineacion};`;
            const vineta = mostrarVinetas ? `<span style="color: ${colorVineta}; font-weight: bold; margin-right: 5px;">•</span>` : '';
            return `<div style="padding-left: ${indentacion}px; margin-bottom: 4px; ${estiloLinea}">${vineta}${linea}</div>`;
        }).join('');
        
        div.innerHTML = `
            <div class="element-controls">
                <button onclick="eliminarElemento('${elemento.id}')" title="Eliminar">
                    <i class="bi bi-trash"></i>
                </button>
                <button onclick="duplicarElemento('${elemento.id}')" title="Duplicar">
                    <i class="bi bi-files"></i>
                </button>
                <button onclick="moverArriba('${elemento.id}')" title="Mover arriba">
                    <i class="bi bi-arrow-up"></i>
                </button>
                <button onclick="moverAbajo('${elemento.id}')" title="Mover abajo">
                    <i class="bi bi-arrow-down"></i>
                </button>
            </div>
            <div class="seccion-preview">
                <div class="seccion-titulo-preview" data-element-id="${elemento.id}" style="font-family: ${tituloFuente} !important; font-size: ${tituloTamano}px !important; font-weight: ${tituloNegrita ? 'bold' : 'normal'} !important; font-style: ${tituloCursiva ? 'italic' : 'normal'} !important; color: ${colorTexto} !important; background-color: ${colorFondo} !important; text-align: ${tituloAlineacion} !important; padding: ${padding} !important; margin-bottom: 8px; position: relative;">
                    <div class="inline-controls-titulo" style="position: absolute; top: -28px; left: 0; display: none; gap: 2px; background: white; padding: 2px 4px; border: 1px solid #ddd; border-radius: 3px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); z-index: 1000; font-size: 0;">
                        <input type="color" value="${colorFondo}" onchange="event.stopPropagation(); actualizarPropiedadSinDeseleccionar('${elemento.id}', 'color_fondo', this.value); this.value = normalizarColor(this.value);" title="Fondo" style="width: 20px; height: 20px; border: 1px solid #ccc; cursor: pointer; padding: 0;">
                        <input type="color" value="${colorTexto}" onchange="event.stopPropagation(); actualizarPropiedadSinDeseleccionar('${elemento.id}', 'color', this.value); this.value = normalizarColor(this.value);" title="Texto" style="width: 20px; height: 20px; border: 1px solid #ccc; cursor: pointer; padding: 0;">
                        <input type="number" value="${tituloTamano}" min="8" max="48" onchange="event.stopPropagation(); actualizarPropiedadSinDeseleccionar('${elemento.id}', 'tamaño', parseInt(this.value) || 14)" title="Tamaño letra" style="width: 40px; padding: 1px 2px; font-size: 0.7rem; border: 1px solid #ccc; text-align: center;">
                        <button onclick="event.stopPropagation(); const el = estructura.find(e => e.id === '${elemento.id}'); if(el) { const negrita = !el.propiedades.negrita; actualizarPropiedadSinDeseleccionar('${elemento.id}', 'negrita', negrita); this.classList.toggle('active'); this.style.background = negrita ? '#007bff' : 'white'; this.style.color = negrita ? 'white' : 'black'; }" class="${tituloNegrita ? 'active' : ''}" title="Negrita" style="padding: 1px 4px; border: 1px solid #ccc; background: ${tituloNegrita ? '#007bff' : 'white'}; color: ${tituloNegrita ? 'white' : 'black'}; cursor: pointer; border-radius: 2px; font-size: 0.7rem; line-height: 1.2;"><strong>N</strong></button>
                        <button onclick="event.stopPropagation(); const el = estructura.find(e => e.id === '${elemento.id}'); if(el) { const cursiva = !el.propiedades.cursiva; actualizarPropiedadSinDeseleccionar('${elemento.id}', 'cursiva', cursiva); this.classList.toggle('active'); this.style.background = cursiva ? '#007bff' : 'white'; this.style.color = cursiva ? 'white' : 'black'; }" class="${tituloCursiva ? 'active' : ''}" title="Cursiva" style="padding: 1px 4px; border: 1px solid #ccc; background: ${tituloCursiva ? '#007bff' : 'white'}; color: ${tituloCursiva ? 'white' : 'black'}; cursor: pointer; border-radius: 2px; font-size: 0.7rem; line-height: 1.2;"><em>K</em></button>
                        <select onchange="event.stopPropagation(); actualizarPropiedadSinDeseleccionar('${elemento.id}', 'alineacion', this.value)" style="padding: 1px 2px; font-size: 0.7rem; border: 1px solid #ccc; height: 20px;">
                            <option value="left" ${tituloAlineacion === 'left' || !tituloAlineacion ? 'selected' : ''}>Izq</option>
                            <option value="center" ${tituloAlineacion === 'center' ? 'selected' : ''}>Cent</option>
                            <option value="right" ${tituloAlineacion === 'right' ? 'selected' : ''}>Der</option>
                        </select>
                    </div>
                    <span class="editable-text" contenteditable="true" onblur="actualizarContenido('${elemento.id}', this.innerHTML)" style="font-family: inherit !important; font-size: inherit !important; font-weight: inherit !important; font-style: inherit !important; color: inherit !important; text-align: inherit !important; background-color: transparent !important;">${elemento.contenido}</span>
                </div>
                <div class="seccion-contenido-preview" style="position: relative; margin-top: 4px;">
                    <div class="inline-controls-contenido" style="position: absolute; bottom: -28px; left: 0; display: none; gap: 2px; background: white; padding: 2px 4px; border: 1px solid #ddd; border-radius: 3px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); z-index: 1000; font-size: 0;">
                        <input type="color" value="${contenidoColor}" onchange="event.stopPropagation(); actualizarPropiedadSinDeseleccionar('${elemento.id}', 'contenido_color', this.value); this.value = normalizarColor(this.value);" title="Color" style="width: 20px; height: 20px; border: 1px solid #ccc; cursor: pointer; padding: 0;">
                        <input type="number" value="${contenidoTamano}" min="8" max="24" onchange="event.stopPropagation(); actualizarPropiedadSinDeseleccionar('${elemento.id}', 'contenido_tamano', parseInt(this.value) || 12)" title="Tamaño" style="width: 35px; padding: 1px 2px; font-size: 0.7rem; border: 1px solid #ccc; text-align: center;">
                        <input type="number" value="${indentacion}" min="0" max="100" onchange="event.stopPropagation(); actualizarPropiedadSinDeseleccionar('${elemento.id}', 'indentacion', parseInt(this.value) || 15)" title="Indent" style="width: 35px; padding: 1px 2px; font-size: 0.7rem; border: 1px solid #ccc; text-align: center;">
                        <input type="checkbox" ${mostrarVinetas ? 'checked' : ''} onchange="event.stopPropagation(); actualizarPropiedadSinDeseleccionar('${elemento.id}', 'mostrar_vinetas', this.checked)" title="Viñetas" style="cursor: pointer; width: 14px; height: 14px; margin: 0;">
                        <input type="color" value="${colorVineta}" onchange="event.stopPropagation(); actualizarPropiedadSinDeseleccionar('${elemento.id}', 'color_vineta', this.value); this.value = normalizarColor(this.value);" title="Viñeta" style="width: 20px; height: 20px; border: 1px solid #ccc; cursor: pointer; padding: 0;">
                        <button onclick="event.stopPropagation(); const el = estructura.find(e => e.id === '${elemento.id}'); if(el) { const negrita = !el.propiedades.contenido_negrita; actualizarPropiedadSinDeseleccionar('${elemento.id}', 'contenido_negrita', negrita); this.classList.toggle('active'); this.style.background = negrita ? '#007bff' : 'white'; this.style.color = negrita ? 'white' : 'black'; }" class="${contenidoNegrita ? 'active' : ''}" title="Negrita" style="padding: 1px 4px; border: 1px solid #ccc; background: ${contenidoNegrita ? '#007bff' : 'white'}; color: ${contenidoNegrita ? 'white' : 'black'}; cursor: pointer; border-radius: 2px; font-size: 0.7rem; line-height: 1.2;"><strong>N</strong></button>
                        <button onclick="event.stopPropagation(); const el = estructura.find(e => e.id === '${elemento.id}'); if(el) { const cursiva = !el.propiedades.contenido_cursiva; actualizarPropiedadSinDeseleccionar('${elemento.id}', 'contenido_cursiva', cursiva); this.classList.toggle('active'); this.style.background = cursiva ? '#007bff' : 'white'; this.style.color = cursiva ? 'white' : 'black'; }" class="${contenidoCursiva ? 'active' : ''}" title="Cursiva" style="padding: 1px 4px; border: 1px solid #ccc; background: ${contenidoCursiva ? '#007bff' : 'white'}; color: ${contenidoCursiva ? 'white' : 'black'}; cursor: pointer; border-radius: 2px; font-size: 0.7rem; line-height: 1.2;"><em>K</em></button>
                        <select onchange="event.stopPropagation(); actualizarPropiedadSinDeseleccionar('${elemento.id}', 'alineacion_contenido', this.value)" style="padding: 1px 2px; font-size: 0.7rem; border: 1px solid #ccc; height: 20px;">
                            <option value="left" ${alineacion === 'left' || !alineacion ? 'selected' : ''}>Izq</option>
                            <option value="center" ${alineacion === 'center' ? 'selected' : ''}>Cent</option>
                            <option value="right" ${alineacion === 'right' ? 'selected' : ''}>Der</option>
                        </select>
                    </div>
                    ${contenidoEjemplo}
                </div>
            </div>
        `;
    } else {
        div.innerHTML = `
            <div class="element-controls">
                <button onclick="eliminarElemento('${elemento.id}')" title="Eliminar">
                    <i class="bi bi-trash"></i>
                </button>
                <button onclick="duplicarElemento('${elemento.id}')" title="Duplicar">
                    <i class="bi bi-files"></i>
                </button>
                <button onclick="moverArriba('${elemento.id}')" title="Mover arriba">
                    <i class="bi bi-arrow-up"></i>
                </button>
                <button onclick="moverAbajo('${elemento.id}')" title="Mover abajo">
                    <i class="bi bi-arrow-down"></i>
                </button>
            </div>
            ${elemento.tipo === 'logo' ? 
                `<div class="element-logo-content">${elemento.contenido}</div>` :
            elemento.tipo === 'protocolo-fecha' ?
                (() => {
                    const props = elemento.propiedades || {};
                    const mostrarTitulo = props.mostrar_titulo !== false;
                    const colorFondo = props.color_fondo || '#e3f2fd';
                    const tituloFuente = props.fuente || 'Arial';
                    const tituloTamano = props.tamaño || 12;
                    const tituloNegrita = props.negrita || false;
                    const tituloCursiva = props.cursiva || false;
                    const tituloColor = props.color || '#007bff';
                    const tituloAlineacion = props.alineacion || 'left';
                    const contenidoFuente = props.contenido_fuente || 'Arial';
                    const contenidoTamano = props.contenido_tamano || 12;
                    const contenidoColor = props.contenido_color || '#333333';
                    const contenidoCursiva = props.contenido_cursiva || false;
                    const mostrarBorde = props.mostrar_borde === true;
                    const estiloBorde = mostrarBorde ? 'border: 1px solid #dee2e6;' : 'border: none;';
                    return `<div class="grupo-datos-preview" style="${estiloBorde} border-radius: 4px; padding: 12px; background: white; margin-bottom: 10px;">
                        ${mostrarTitulo ? `<div class="grupo-titulo-preview editable-text" contenteditable="true" onblur="actualizarContenido('${elemento.id}', this.innerHTML)" style="font-family: ${tituloFuente} !important; font-size: ${tituloTamano}px !important; font-weight: ${tituloNegrita ? 'bold' : 'normal'} !important; font-style: ${tituloCursiva ? 'italic' : 'normal'} !important; color: ${tituloColor} !important; background-color: ${colorFondo} !important; text-align: ${tituloAlineacion} !important; padding: 8px 12px !important; margin-bottom: 8px !important; border-radius: 3px;">${elemento.contenido}</div>` : ''}
                        <div class="campo-preview" style="margin-bottom: 4px; font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-style: ${contenidoCursiva ? 'italic' : 'normal'};"><span style="font-weight: 600;">Protocolo:</span> <span style="color: #666;">[NUMERO]</span></div>
                        <div class="campo-preview" style="font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-style: ${contenidoCursiva ? 'italic' : 'normal'};"><span style="font-weight: 600;">Fecha:</span> <span style="color: #666;">[FECHA]</span></div>
                    </div>`;
                })() :
            elemento.tipo === 'datos-paciente' ?
                (() => {
                    const props = elemento.propiedades || {};
                    const mostrarTitulo = props.mostrar_titulo !== false;
                    const colorFondo = props.color_fondo || '#e3f2fd';
                    const tituloFuente = props.fuente || 'Arial';
                    const tituloTamano = props.tamaño || 12;
                    const tituloNegrita = props.negrita || false;
                    const tituloCursiva = props.cursiva || false;
                    const tituloColor = props.color || '#007bff';
                    const tituloAlineacion = props.alineacion || 'left';
                    const contenidoFuente = props.contenido_fuente || 'Arial';
                    const contenidoTamano = props.contenido_tamano || 12;
                    const contenidoColor = props.contenido_color || '#333333';
                    const contenidoCursiva = props.contenido_cursiva || false;
                    const mostrarBorde = props.mostrar_borde === true;
                    const estiloBorde = mostrarBorde ? 'border: 1px solid #dee2e6;' : 'border: none;';
                    return `<div class="grupo-datos-preview" style="${estiloBorde} border-radius: 4px; padding: 12px; background: white; margin-bottom: 10px;">
                        ${mostrarTitulo ? `<div class="grupo-titulo-preview editable-text" contenteditable="true" onblur="actualizarContenido('${elemento.id}', this.innerHTML)" style="font-family: ${tituloFuente} !important; font-size: ${tituloTamano}px !important; font-weight: ${tituloNegrita ? 'bold' : 'normal'} !important; font-style: ${tituloCursiva ? 'italic' : 'normal'} !important; color: ${tituloColor} !important; background-color: ${colorFondo} !important; text-align: ${tituloAlineacion} !important; padding: 8px 12px !important; margin-bottom: 8px !important; border-radius: 3px;">${elemento.contenido}</div>` : ''}
                        <div class="campo-preview" style="margin-bottom: 4px; font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-style: ${contenidoCursiva ? 'italic' : 'normal'};"><span style="font-weight: 600;">Paciente:</span> <span style="color: #666;">[NOMBRE]</span></div>
                        <div class="campo-preview" style="margin-bottom: 4px; font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-style: ${contenidoCursiva ? 'italic' : 'normal'};"><span style="font-weight: 600;">DNI:</span> <span style="color: #666;">[DNI]</span></div>
                        <div class="campo-preview" style="margin-bottom: 4px; font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-style: ${contenidoCursiva ? 'italic' : 'normal'};"><span style="font-weight: 600;">Edad:</span> <span style="color: #666;">[EDAD] años</span></div>
                        <div class="campo-preview" style="font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-style: ${contenidoCursiva ? 'italic' : 'normal'};"><span style="font-weight: 600;">Obra Social:</span> <span style="color: #666;">[OBRA_SOCIAL]</span></div>
                    </div>`;
                })() :
            elemento.tipo === 'datos-medico' ?
                (() => {
                    const props = elemento.propiedades || {};
                    const mostrarTitulo = props.mostrar_titulo !== false;
                    const colorFondo = props.color_fondo || '#e3f2fd';
                    const tituloFuente = props.fuente || 'Arial';
                    const tituloTamano = props.tamaño || 12;
                    const tituloNegrita = props.negrita || false;
                    const tituloCursiva = props.cursiva || false;
                    const tituloColor = props.color || '#007bff';
                    const tituloAlineacion = props.alineacion || 'left';
                    const contenidoFuente = props.contenido_fuente || 'Arial';
                    const contenidoTamano = props.contenido_tamano || 12;
                    const contenidoColor = props.contenido_color || '#333333';
                    const contenidoCursiva = props.contenido_cursiva || false;
                    const mostrarBorde = props.mostrar_borde === true;
                    const estiloBorde = mostrarBorde ? 'border: 1px solid #dee2e6;' : 'border: none;';
                    return `<div class="grupo-datos-preview" style="${estiloBorde} border-radius: 4px; padding: 12px; background: white; margin-bottom: 10px;">
                        ${mostrarTitulo ? `<div class="grupo-titulo-preview editable-text" contenteditable="true" onblur="actualizarContenido('${elemento.id}', this.innerHTML)" style="font-family: ${tituloFuente} !important; font-size: ${tituloTamano}px !important; font-weight: ${tituloNegrita ? 'bold' : 'normal'} !important; font-style: ${tituloCursiva ? 'italic' : 'normal'} !important; color: ${tituloColor} !important; background-color: ${colorFondo} !important; text-align: ${tituloAlineacion} !important; padding: 8px 12px !important; margin-bottom: 8px !important; border-radius: 3px;">${elemento.contenido}</div>` : ''}
                        <div class="campo-preview" style="margin-bottom: 4px; font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-style: ${contenidoCursiva ? 'italic' : 'normal'};"><span style="font-weight: 600;">Médico:</span> <span style="color: #666;">[NOMBRE_MEDICO]</span></div>
                        <div class="campo-preview" style="font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-style: ${contenidoCursiva ? 'italic' : 'normal'};"><span style="font-weight: 600;">Especialidad:</span> <span style="color: #666;">[ESPECIALIDAD]</span></div>
                    </div>`;
                })() :
            elemento.tipo === 'datos-paciente-medico' ?
                (() => {
                    const props = elemento.propiedades || {};
                    const mostrarTitulo = props.mostrar_titulo !== false;
                    const colorFondo = props.color_fondo || '#e3f2fd';
                    const tituloFuente = props.fuente || 'Arial';
                    const tituloTamano = props.tamaño || 12;
                    const tituloNegrita = props.negrita || false;
                    const tituloCursiva = props.cursiva || false;
                    const tituloColor = props.color || '#007bff';
                    const tituloAlineacion = props.alineacion || 'left';
                    const contenidoFuente = props.contenido_fuente || 'Arial';
                    const contenidoTamano = props.contenido_tamano || 12;
                    const contenidoColor = props.contenido_color || '#333333';
                    const contenidoCursiva = props.contenido_cursiva || false;
                    const mostrarBorde = props.mostrar_borde === true;
                    const estiloBorde = mostrarBorde ? 'border: 1px solid #dee2e6;' : 'border: none;';
                    return `<div class="grupo-datos-preview" style="display: flex; gap: 10px; margin-bottom: 10px; ${estiloBorde} border-radius: 4px; padding: 12px; background: white;">
                        <!-- Columna Paciente -->
                        <div style="flex: 1;">
                            <div class="grupo-titulo-preview" style="font-family: ${tituloFuente} !important; font-size: ${tituloTamano}px !important; font-weight: ${tituloNegrita ? 'bold' : 'normal'} !important; font-style: ${tituloCursiva ? 'italic' : 'normal'} !important; color: ${tituloColor} !important; background-color: ${colorFondo} !important; text-align: ${tituloAlineacion} !important; padding: 8px 12px !important; margin-bottom: 8px !important; border-radius: 3px;">DATOS DEL PACIENTE</div>
                            <div class="campo-preview" style="margin-bottom: 4px; font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-style: ${contenidoCursiva ? 'italic' : 'normal'};"><span style="font-weight: 600;">Paciente:</span> <span style="color: #666;">[NOMBRE]</span></div>
                            <div class="campo-preview" style="margin-bottom: 4px; font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-style: ${contenidoCursiva ? 'italic' : 'normal'};"><span style="font-weight: 600;">DNI:</span> <span style="color: #666;">[DNI]</span></div>
                            <div class="campo-preview" style="margin-bottom: 4px; font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-style: ${contenidoCursiva ? 'italic' : 'normal'};"><span style="font-weight: 600;">Edad:</span> <span style="color: #666;">[EDAD] años</span></div>
                            <div class="campo-preview" style="font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-style: ${contenidoCursiva ? 'italic' : 'normal'};"><span style="font-weight: 600;">Obra Social:</span> <span style="color: #666;">[OBRA_SOCIAL]</span></div>
                        </div>
                        <!-- Columna Médico -->
                        <div style="flex: 1;">
                            <div class="grupo-titulo-preview" style="font-family: ${tituloFuente} !important; font-size: ${tituloTamano}px !important; font-weight: ${tituloNegrita ? 'bold' : 'normal'} !important; font-style: ${tituloCursiva ? 'italic' : 'normal'} !important; color: ${tituloColor} !important; background-color: ${colorFondo} !important; text-align: ${tituloAlineacion} !important; padding: 8px 12px !important; margin-bottom: 8px !important; border-radius: 3px;">DATOS DEL MÉDICO</div>
                            <div class="campo-preview" style="margin-bottom: 4px; font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-style: ${contenidoCursiva ? 'italic' : 'normal'};"><span style="font-weight: 600;">Médico:</span> <span style="color: #666;">[NOMBRE_MEDICO]</span></div>
                            <div class="campo-preview" style="font-family: ${contenidoFuente}; font-size: ${contenidoTamano}px; color: ${contenidoColor}; font-style: ${contenidoCursiva ? 'italic' : 'normal'};"><span style="font-weight: 600;">Especialidad:</span> <span style="color: #666;">[ESPECIALIDAD]</span></div>
                        </div>
                    </div>`;
                })() :
                `<div class="editable-text" contenteditable="true" onblur="actualizarContenido('${elemento.id}', this.innerHTML)">
                    ${elemento.contenido}
                </div>`
            }
        `;
    }
    
    aplicarPropiedades(div, elemento.propiedades);
    
    div.addEventListener('click', (e) => {
        if (e.target.closest('.element-controls')) return;
        seleccionarElemento(elemento.id);
    });
    
    div.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('element-id', elemento.id);
        e.dataTransfer.effectAllowed = 'move';
        div.style.opacity = '0.5';
    });
    
    div.addEventListener('dragend', (e) => {
        div.style.opacity = '1';
    });
    
    // Añadir el elemento al contenedor de contenido del canvas
    const canvasContentFinal = document.getElementById('canvas-content');
    if (canvasContentFinal) {
        canvasContentFinal.appendChild(div);
    } else {
        const canvas = document.getElementById('report-canvas');
        if (canvas) {
            canvas.appendChild(div);
        }
    }
    
    // Configurar drag and drop para reordenar
    configurarDragReordenamiento(div);
    
    // Los estilos ya están aplicados directamente en el HTML generado
    // No necesitamos aplicar estilos adicionales aquí
    
    return div; // Retornar el div para uso en otras funciones
}

function aplicarPropiedades(elemento, props) {
    const editable = elemento.querySelector('.editable-text');
    if (editable) {
        editable.style.fontFamily = props.fuente || 'Arial';
        editable.style.fontSize = (props.tamaño || 12) + 'px';
        editable.style.color = props.color || '#000000';
        editable.style.textAlign = props.alineacion || 'left';
        editable.style.fontWeight = props.negrita ? 'bold' : 'normal';
        editable.style.fontStyle = props.cursiva ? 'italic' : 'normal';
    }
    
    // Aplicar márgenes al contenedor del elemento (siempre aplicar, incluso si es 0)
    const margenSup = props.margen_superior !== undefined && props.margen_superior !== null ? props.margen_superior : 0;
    const margenInf = props.margen_inferior !== undefined && props.margen_inferior !== null ? props.margen_inferior : 10;
    const margenIzq = props.margen_izquierdo !== undefined && props.margen_izquierdo !== null ? props.margen_izquierdo : 0;
    const margenDer = props.margen_derecho !== undefined && props.margen_derecho !== null ? props.margen_derecho : 0;
    elemento.style.marginTop = margenSup + 'px';
    elemento.style.marginBottom = margenInf + 'px';
    elemento.style.marginLeft = margenIzq + 'px';
    elemento.style.marginRight = margenDer + 'px';
    
    // Aplicar tamaño del elemento
    if (props.ancho !== null && props.ancho !== undefined && props.ancho !== '') {
        elemento.style.width = props.ancho + (props.ancho_unit || 'px');
    } else {
        elemento.style.width = '';
    }
    if (props.alto !== null && props.alto !== undefined && props.alto !== '') {
        elemento.style.height = props.alto + (props.alto_unit || 'px');
        elemento.style.minHeight = props.alto + (props.alto_unit || 'px');
    } else {
        elemento.style.height = '';
        elemento.style.minHeight = '';
    }
    
    // Aplicar posición y display
    if (props.posicion === 'absolute') {
        elemento.style.position = 'absolute';
        elemento.classList.add('posicion-absoluta');
        
        // Para posicionamiento absoluto, sumar los márgenes de la hoja para que sea relativo al área de contenido
        const margenSupInput = document.getElementById('config-margen-hoja-superior');
        const margenIzqInput = document.getElementById('config-margen-hoja-izquierdo');
        const mmToPx = 3.779527559;
        const margenSup = (margenSupInput ? parseInt(margenSupInput.value || 20) : 20) * mmToPx;
        const margenIzq = (margenIzqInput ? parseInt(margenIzqInput.value || 20) : 20) * mmToPx;
        
        if (props.top !== undefined && props.top !== null) {
            elemento.style.top = (props.top + margenSup) + 'px';
        }
        if (props.left !== undefined && props.left !== null) {
            elemento.style.left = (props.left + margenIzq) + 'px';
        }
    } else if (props.posicion === 'inline') {
        elemento.style.position = 'relative';
        elemento.style.display = 'inline-block';
        elemento.classList.remove('posicion-absoluta');
        elemento.style.top = '';
        elemento.style.left = '';
    } else {
        // Bloque (por defecto)
        elemento.style.position = 'relative';
        elemento.style.display = 'block';
        elemento.classList.remove('posicion-absoluta');
        elemento.style.top = '';
        elemento.style.left = '';
    }
    
    if (!props.mostrar) {
        elemento.style.display = 'none';
    }
}

function seleccionarElemento(id) {
    // Ocultar controles inline de todos los elementos
    document.querySelectorAll('.inline-controls-titulo, .inline-controls-contenido').forEach(ctrl => {
        ctrl.style.display = 'none';
    });
    
    // Deseleccionar anterior
    if (elementoSeleccionado) {
        const prev = document.getElementById(elementoSeleccionado);
        if (prev) prev.classList.remove('selected');
    }
    
    // Seleccionar nuevo
    elementoSeleccionado = id;
    const elemento = document.getElementById(id);
    if (elemento) {
        elemento.classList.add('selected');
        
        // Mostrar controles inline si es una sección
        const elementoData = estructura.find(e => e.id === id);
        if (elementoData && elementoData.tipo === 'seccion') {
            const controlesTitulo = elemento.querySelector('.inline-controls-titulo');
            const controlesContenido = elemento.querySelector('.inline-controls-contenido');
            if (controlesTitulo) controlesTitulo.style.display = 'flex';
            if (controlesContenido) controlesContenido.style.display = 'flex';
        }
        
        mostrarPropiedades(id);
    }
}

function mostrarPropiedades(id) {
    const elemento = estructura.find(e => e.id === id);
    if (!elemento) return;
    
    // Determinar si es un elemento de datos (protocolo-fecha, datos-paciente, datos-medico, datos-paciente-medico)
    const esElementoDatos = ['protocolo-fecha', 'datos-paciente', 'datos-medico', 'datos-paciente-medico'].includes(elemento.tipo);
    
    const panel = document.getElementById('properties-panel');
    panel.innerHTML = `
        <h6 style="margin-bottom: 8px;"><i class="bi bi-sliders"></i> ${elemento.tipo}</h6>
        
        ${esElementoDatos ? `
        <!-- OPCIONES ESPECIALES PARA ELEMENTOS DE DATOS -->
        <div class="ribbon-group" style="margin-bottom: 8px; border: 1px solid #dee2e6; padding: 8px; background: #fff;">
            <div class="ribbon-group-title" style="font-size: 0.75rem; font-weight: bold; color: #495057; margin-bottom: 6px;">OPCIONES</div>
            <div class="form-check" style="margin-bottom: 6px;">
                <input class="form-check-input" type="checkbox" id="prop-mostrar-titulo" ${elemento.propiedades.mostrar_titulo !== false ? 'checked' : ''}
                       onchange="actualizarPropiedad('${id}', 'mostrar_titulo', this.checked)">
                <label class="form-check-label" style="font-size: 0.75rem;" for="prop-mostrar-titulo">
                    Mostrar título
                </label>
            </div>
            <div class="form-check" style="margin-bottom: 6px;">
                <input class="form-check-input" type="checkbox" id="prop-mostrar-borde" ${elemento.propiedades.mostrar_borde === true ? 'checked' : ''}
                       onchange="actualizarPropiedad('${id}', 'mostrar_borde', this.checked)">
                <label class="form-check-label" style="font-size: 0.75rem;" for="prop-mostrar-borde">
                    Mostrar borde
                </label>
            </div>
        </div>
        ` : ''}
        
        <!-- TÍTULO: Fuente -->
        <div class="ribbon-group" style="margin-bottom: 8px;">
            <div class="ribbon-group-title" style="font-size: 0.75rem; font-weight: bold; color: #495057; margin-bottom: 4px;">TÍTULO</div>
            <div class="ribbon-group-title" style="font-size: 0.7rem; color: #6c757d; margin-bottom: 6px;">Fuente</div>
            <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                <select id="prop-fuente" class="ribbon-select-compact" onchange="actualizarPropiedad('${id}', 'fuente', this.value)" style="flex: 1; min-width: 120px;">
                    <option value="Arial" ${elemento.propiedades.fuente === 'Arial' ? 'selected' : ''}>Arial</option>
                    <option value="Times New Roman" ${elemento.propiedades.fuente === 'Times New Roman' ? 'selected' : ''}>Times New Roman</option>
                    <option value="Helvetica" ${elemento.propiedades.fuente === 'Helvetica' ? 'selected' : ''}>Helvetica</option>
                    <option value="Courier New" ${elemento.propiedades.fuente === 'Courier New' ? 'selected' : ''}>Courier New</option>
                </select>
                <div class="ribbon-input-compact">
                    <input type="number" id="prop-tamaño" value="${elemento.propiedades.tamaño}" 
                           min="8" max="72" onchange="actualizarPropiedad('${id}', 'tamaño', parseInt(this.value))"
                           placeholder="Tamaño">
                </div>
            </div>
        </div>
        
        <!-- Grupo Formato -->
        <div class="ribbon-group">
            <div class="ribbon-group-title">Formato</div>
            <div class="ribbon-buttons">
                <button class="ribbon-button ${elemento.propiedades.negrita ? 'active' : ''}" 
                        onclick="const el = estructura.find(e => e.id === '${id}'); if(el) { const negrita = !el.propiedades.negrita; actualizarPropiedad('${id}', 'negrita', negrita); this.classList.toggle('active'); }"
                        title="Negrita">
                    <strong>N</strong>
                </button>
                <button class="ribbon-button ${elemento.propiedades.cursiva ? 'active' : ''}" 
                        onclick="const el = estructura.find(e => e.id === '${id}'); if(el) { const cursiva = !el.propiedades.cursiva; actualizarPropiedad('${id}', 'cursiva', cursiva); this.classList.toggle('active'); }"
                        title="Cursiva">
                    <em>K</em>
                </button>
                <div class="ribbon-input-compact" style="margin-left: auto;">
                    <input type="color" id="prop-color" value="${elemento.propiedades.color || '#000000'}" 
                           onchange="actualizarPropiedad('${id}', 'color', this.value)" 
                           title="Color del texto">
                </div>
            </div>
        </div>
        
        ${esElementoDatos ? `
        <!-- Color de fondo del título -->
        <div class="ribbon-group" style="margin-bottom: 8px;">
            <div class="ribbon-group-title" style="font-size: 0.7rem; color: #6c757d; margin-bottom: 6px;">Fondo Título</div>
            <input type="color" id="prop-color-fondo" value="${elemento.propiedades.color_fondo || '#e3f2fd'}" 
                   onchange="actualizarPropiedad('${id}', 'color_fondo', this.value)" 
                   title="Color de fondo del título"
                   style="width: 100%; height: 32px; border: 1px solid #ced4da; border-radius: 3px;">
        </div>
        ` : ''}
        
        <!-- TÍTULO: Alineación -->
        <div class="ribbon-group" style="margin-bottom: 8px;">
            <div class="ribbon-group-title" style="font-size: 0.7rem; color: #6c757d; margin-bottom: 6px;">Alineación</div>
            <div class="ribbon-button-group">
                <button class="${elemento.propiedades.alineacion === 'left' || !elemento.propiedades.alineacion ? 'active' : ''}" 
                        onclick="actualizarPropiedad('${id}', 'alineacion', 'left'); this.parentElement.querySelectorAll('button').forEach(b => b.classList.remove('active')); this.classList.add('active');"
                        title="Alineación Izquierda">
                    <i class="bi bi-text-left"></i>
                </button>
                <button class="${elemento.propiedades.alineacion === 'center' ? 'active' : ''}" 
                        onclick="actualizarPropiedad('${id}', 'alineacion', 'center'); this.parentElement.querySelectorAll('button').forEach(b => b.classList.remove('active')); this.classList.add('active');"
                        title="Centrar">
                    <i class="bi bi-text-center"></i>
                </button>
                <button class="${elemento.propiedades.alineacion === 'right' ? 'active' : ''}" 
                        onclick="actualizarPropiedad('${id}', 'alineacion', 'right'); this.parentElement.querySelectorAll('button').forEach(b => b.classList.remove('active')); this.classList.add('active');"
                        title="Alineación Derecha">
                    <i class="bi bi-text-right"></i>
                </button>
            </div>
        </div>
        
        ${esElementoDatos ? `
        <!-- CONTENIDO: Configuración del contenido de los campos -->
        <div class="ribbon-group" style="margin-bottom: 8px; border: 1px solid #dee2e6; padding: 8px; background: #fff;">
            <div class="ribbon-group-title" style="font-size: 0.75rem; font-weight: bold; color: #495057; margin-bottom: 6px;">CONTENIDO</div>
            
            <!-- Tamaño y Fuente del contenido -->
            <div class="ribbon-group-title" style="font-size: 0.7rem; color: #6c757d; margin-bottom: 6px;">Fuente</div>
            <div style="display: flex; gap: 4px; flex-wrap: wrap; margin-bottom: 8px;">
                <select id="prop-contenido-fuente" class="ribbon-select-compact" onchange="actualizarPropiedad('${id}', 'contenido_fuente', this.value)" style="flex: 1; min-width: 120px;">
                    <option value="Arial" ${(elemento.propiedades.contenido_fuente || 'Arial') === 'Arial' ? 'selected' : ''}>Arial</option>
                    <option value="Times New Roman" ${(elemento.propiedades.contenido_fuente || 'Arial') === 'Times New Roman' ? 'selected' : ''}>Times New Roman</option>
                    <option value="Helvetica" ${(elemento.propiedades.contenido_fuente || 'Arial') === 'Helvetica' ? 'selected' : ''}>Helvetica</option>
                    <option value="Courier New" ${(elemento.propiedades.contenido_fuente || 'Arial') === 'Courier New' ? 'selected' : ''}>Courier New</option>
                </select>
                <div class="ribbon-input-compact">
                    <input type="number" id="prop-contenido-tamano" value="${elemento.propiedades.contenido_tamano || 12}" 
                           min="8" max="24" onchange="actualizarPropiedad('${id}', 'contenido_tamano', parseInt(this.value) || 12)"
                           placeholder="Tamaño">
                </div>
            </div>
            
            <!-- Grupo Formato del contenido (igual que el título) -->
            <div class="ribbon-group">
                <div class="ribbon-group-title">Formato</div>
                <div class="ribbon-buttons">
                    <button class="ribbon-button ${elemento.propiedades.contenido_cursiva ? 'active' : ''}" 
                            onclick="const el = estructura.find(e => e.id === '${id}'); if(el) { const cursiva = !el.propiedades.contenido_cursiva; actualizarPropiedad('${id}', 'contenido_cursiva', cursiva); this.classList.toggle('active'); }"
                            title="Cursiva">
                        <em>K</em>
                    </button>
                    <div class="ribbon-input-compact" style="margin-left: auto;">
                        <input type="color" id="prop-contenido-color" value="${elemento.propiedades.contenido_color || '#333333'}" 
                               onchange="actualizarPropiedad('${id}', 'contenido_color', this.value)" 
                               title="Color del contenido">
                    </div>
                </div>
            </div>
        </div>
        ` : ''}
            
            <!-- POSICIÓN -->
            <div class="ribbon-group" style="margin-top: 8px; margin-bottom: 6px; border-top: 1px solid #dee2e6; padding-top: 8px;">
                <div class="ribbon-group-title" style="font-size: 0.75rem; font-weight: bold; color: #495057; margin-bottom: 4px;">POSICIÓN</div>
                <select id="prop-posicion-tipo" onchange="cambiarTipoPosicion('${id}', this.value)"
                        style="width: 100%; padding: 3px; font-size: 0.75rem;">
                    <option value="block" ${(!elemento.propiedades.posicion || elemento.propiedades.posicion === 'relative') ? 'selected' : ''}>Bloque</option>
                    <option value="inline" ${elemento.propiedades.posicion === 'inline' ? 'selected' : ''}>En línea</option>
                    <option value="absolute" ${elemento.propiedades.posicion === 'absolute' ? 'selected' : ''}>Absoluto</option>
                </select>
                ${elemento.propiedades.posicion === 'absolute' ? `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-top: 4px;">
                    <input type="number" id="prop-top" value="${elemento.propiedades.top || 0}" 
                           placeholder="Top" title="Desde arriba"
                           onchange="actualizarPropiedad('${id}', 'top', parseFloat(this.value) || 0)"
                           style="width: 100%; padding: 3px; font-size: 0.75rem;">
                    <input type="number" id="prop-left" value="${elemento.propiedades.left || 0}" 
                           placeholder="Left" title="Desde izquierda"
                           onchange="actualizarPropiedad('${id}', 'left', parseFloat(this.value) || 0)"
                           style="width: 100%; padding: 3px; font-size: 0.75rem;">
                </div>
                ` : ''}
            </div>
            
            <!-- TAMAÑO -->
            <div class="ribbon-group" style="margin-bottom: 6px;">
                <div class="ribbon-group-title" style="font-size: 0.75rem; font-weight: bold; color: #495057; margin-bottom: 4px;">TAMAÑO</div>
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 4px;">
                    <input type="number" id="prop-ancho" value="${elemento.propiedades.ancho || ''}" 
                           placeholder="Ancho" min="0" 
                           onchange="actualizarPropiedad('${id}', 'ancho', this.value ? parseFloat(this.value) : null)"
                           style="width: 100%; padding: 3px; font-size: 0.75rem;">
                    <select id="prop-ancho-unit" onchange="actualizarPropiedad('${id}', 'ancho_unit', this.value)"
                            style="width: 100%; padding: 3px; font-size: 0.75rem;">
                        <option value="px" ${(elemento.propiedades.ancho_unit || 'px') === 'px' ? 'selected' : ''}>px</option>
                        <option value="%" ${(elemento.propiedades.ancho_unit || 'px') === '%' ? 'selected' : ''}>%</option>
                        <option value="mm" ${(elemento.propiedades.ancho_unit || 'px') === 'mm' ? 'selected' : ''}>mm</option>
                    </select>
                </div>
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 4px; margin-top: 4px;">
                    <input type="number" id="prop-alto" value="${elemento.propiedades.alto || ''}" 
                           placeholder="Alto" min="0" 
                           onchange="actualizarPropiedad('${id}', 'alto', this.value ? parseFloat(this.value) : null)"
                           style="width: 100%; padding: 3px; font-size: 0.75rem;">
                    <select id="prop-alto-unit" onchange="actualizarPropiedad('${id}', 'alto_unit', this.value)"
                            style="width: 100%; padding: 3px; font-size: 0.75rem;">
                        <option value="px" ${(elemento.propiedades.alto_unit || 'px') === 'px' ? 'selected' : ''}>px</option>
                        <option value="%" ${(elemento.propiedades.alto_unit || 'px') === '%' ? 'selected' : ''}>%</option>
                        <option value="mm" ${(elemento.propiedades.alto_unit || 'px') === 'mm' ? 'selected' : ''}>mm</option>
                    </select>
                </div>
            </div>
            
            <!-- MÁRGENES -->
            <div class="ribbon-group" style="margin-bottom: 6px;">
                <div class="ribbon-group-title" style="font-size: 0.75rem; font-weight: bold; color: #495057; margin-bottom: 4px;">MÁRGENES</div>
                <div style="display: grid; grid-template-columns: auto 1fr 1fr; gap: 4px; align-items: center;">
                    <label style="font-size: 0.7rem; color: #6c757d; margin: 0; padding-right: 4px;">VERT</label>
                    <input type="number" id="prop-margen-sup" value="${(elemento.propiedades.margen_superior ?? 0)}" 
                           placeholder="0" min="0" title="Margen Superior"
                           onchange="actualizarPropiedad('${id}', 'margen_superior', (this.value === '' ? 0 : parseInt(this.value)))"
                           style="width: 100%; padding: 2px 3px; font-size: 0.7rem;">
                    <input type="number" id="prop-margen-inf" value="${(elemento.propiedades.margen_inferior ?? 10)}" 
                           placeholder="0" min="0" title="Margen Inferior"
                           onchange="actualizarPropiedad('${id}', 'margen_inferior', (this.value === '' ? 0 : parseInt(this.value)))"
                           style="width: 100%; padding: 2px 3px; font-size: 0.7rem;">
                </div>
                <div style="display: grid; grid-template-columns: auto 1fr 1fr; gap: 4px; align-items: center; margin-top: 4px;">
                    <label style="font-size: 0.7rem; color: #6c757d; margin: 0; padding-right: 4px;">HOR</label>
                    <input type="number" id="prop-margen-izq" value="${(elemento.propiedades.margen_izquierdo ?? 0)}" 
                           placeholder="0" min="0" title="Margen Izquierdo"
                           onchange="actualizarPropiedad('${id}', 'margen_izquierdo', (this.value === '' ? 0 : parseInt(this.value)))"
                           style="width: 100%; padding: 2px 3px; font-size: 0.7rem;">
                    <input type="number" id="prop-margen-der" value="${(elemento.propiedades.margen_derecho ?? 0)}" 
                           placeholder="0" min="0" title="Margen Derecho"
                           onchange="actualizarPropiedad('${id}', 'margen_derecho', (this.value === '' ? 0 : parseInt(this.value)))"
                           style="width: 100%; padding: 2px 3px; font-size: 0.7rem;">
                </div>
            </div>
    `;
}

function cambiarTipoPosicion(id, tipo) {
    const elemento = estructura.find(e => e.id === id);
    if (elemento) {
        if (tipo === 'inline') {
            elemento.propiedades.posicion = 'inline';
        } else if (tipo === 'absolute') {
            elemento.propiedades.posicion = 'absolute';
            if (!elemento.propiedades.top && elemento.propiedades.top !== 0) {
                elemento.propiedades.top = 0;
            }
            if (!elemento.propiedades.left && elemento.propiedades.left !== 0) {
                elemento.propiedades.left = 0;
            }
        } else {
            elemento.propiedades.posicion = 'relative';
            elemento.propiedades.top = null;
            elemento.propiedades.left = null;
        }
        
        const div = document.getElementById(id);
        if (div) {
            aplicarPropiedades(div, elemento.propiedades);
            // Regenerar panel de propiedades para mostrar campos de posición si es necesario
            mostrarPropiedades(id);
        }
    }
}

function actualizarPropiedad(id, propiedad, valor) {
    const elemento = estructura.find(e => e.id === id);
    if (elemento) {
        // Normalizar colores antes de guardar
        if (propiedad.includes('color') && valor && typeof valor === 'string') {
            valor = normalizarColor(valor);
        }
        // Asegurar que los márgenes se guarden como números, incluso si son 0
        if (propiedad.includes('margen')) {
            valor = valor === '' || valor === null || valor === undefined ? 0 : parseInt(valor) || 0;
        }
        elemento.propiedades[propiedad] = valor;
        const div = document.getElementById(id);
        if (div) {
            // Si es una sección o elemento de datos y cambia una propiedad que afecta el renderizado completo, re-renderizar
            const esElementoDatos = ['protocolo-fecha', 'datos-paciente', 'datos-medico', 'datos-paciente-medico'].includes(elemento.tipo);
            if ((elemento.tipo === 'seccion' || esElementoDatos) && (propiedad.includes('color') || propiedad.includes('fondo') || propiedad.includes('indentacion') || propiedad.includes('vineta') || propiedad.includes('contenido') || propiedad === 'borde_izquierdo' || propiedad === 'negrita' || propiedad === 'cursiva' || propiedad === 'contenido_cursiva' || propiedad === 'alineacion' || propiedad === 'tamaño' || propiedad === 'fuente' || propiedad === 'mostrar_titulo' || propiedad === 'mostrar_borde')) {
                const parent = div.parentNode;
                const next = div.nextSibling; // conservar posición
                div.remove();
                renderizarElemento(elemento);
                const nuevoDiv = document.getElementById(id);
                if (parent && nuevoDiv) {
                    if (next) {
                        parent.insertBefore(nuevoDiv, next);
                    } else {
                        parent.appendChild(nuevoDiv);
                    }
                }
                // Reseleccionar para mantener el foco y mostrar controles
                seleccionarElemento(id);
            } else {
                aplicarPropiedades(div, elemento.propiedades);
            }
            console.log('Propiedad actualizada:', propiedad, '=', valor, 'en elemento', id);
        } else {
            console.error('No se encontró el elemento DOM con id:', id);
        }
    } else {
        console.error('No se encontró el elemento en estructura con id:', id);
    }
}

function actualizarPropiedadSinDeseleccionar(id, propiedad, valor) {
    // Similar a actualizarPropiedad pero sin deseleccionar el elemento
    const elemento = estructura.find(e => e.id === id);
    if (elemento) {
        // Normalizar colores antes de guardar
        if (propiedad.includes('color') && valor && typeof valor === 'string') {
            valor = normalizarColor(valor);
        }
        elemento.propiedades[propiedad] = valor;
        const div = document.getElementById(id);
        if (div) {
            // Si es una sección o elemento de datos y cambia una propiedad que afecta el renderizado completo, re-renderizar
            const esElementoDatos = ['protocolo-fecha', 'datos-paciente', 'datos-medico', 'datos-paciente-medico'].includes(elemento.tipo);
            if ((elemento.tipo === 'seccion' || esElementoDatos) && (propiedad.includes('color') || propiedad.includes('fondo') || propiedad.includes('indentacion') || propiedad.includes('vineta') || propiedad.includes('contenido') || propiedad === 'borde_izquierdo' || propiedad === 'negrita' || propiedad === 'cursiva' || propiedad === 'contenido_cursiva' || propiedad === 'alineacion' || propiedad === 'tamaño' || propiedad === 'fuente' || propiedad === 'mostrar_titulo' || propiedad === 'mostrar_borde')) {
                const fueSeleccionado = elementoSeleccionado === id;
                const parent = div.parentNode;
                const next = div.nextSibling; // conservar posición
                div.remove();
                renderizarElemento(elemento);
                const nuevoDiv = document.getElementById(id);
                if (parent && nuevoDiv) {
                    if (next) {
                        parent.insertBefore(nuevoDiv, next);
                    } else {
                        parent.appendChild(nuevoDiv);
                    }
                }
                // Si estaba seleccionado, mantenerlo seleccionado sin llamar a seleccionarElemento (que oculta los controles)
                if (fueSeleccionado && nuevoDiv) {
                    nuevoDiv.classList.add('selected');
                    const controlesTitulo = nuevoDiv.querySelector('.inline-controls-titulo');
                    const controlesContenido = nuevoDiv.querySelector('.inline-controls-contenido');
                    if (controlesTitulo) controlesTitulo.style.display = 'flex';
                    if (controlesContenido) controlesContenido.style.display = 'flex';
                    mostrarPropiedades(id);
                }
            } else {
                aplicarPropiedades(div, elemento.propiedades);
            }
            console.log('Propiedad actualizada:', propiedad, '=', valor, 'en elemento', id);
        } else {
            console.error('No se encontró el elemento DOM con id:', id);
        }
    } else {
        console.error('No se encontró el elemento en estructura con id:', id);
    }
}

function actualizarContenido(id, contenido) {
    const elemento = estructura.find(e => e.id === id);
    if (elemento) {
        // Para elementos no-logo, usar innerHTML; para logo, mantener HTML
        if (elemento.tipo === 'logo') {
            // El logo mantiene su HTML
            const div = document.getElementById(id);
            if (div) {
                const logoContent = div.querySelector('.element-logo-content');
                if (logoContent) {
                    elemento.contenido = logoContent.innerHTML;
                }
            }
        } else {
            elemento.contenido = contenido;
        }
    }
}

function eliminarElemento(id) {
    estructura = estructura.filter(e => e.id !== id);
    const div = document.getElementById(id);
    if (div) div.remove();
    if (elementoSeleccionado === id) {
        elementoSeleccionado = null;
        document.getElementById('properties-panel').innerHTML = '<h6>Propiedades</h6><p class="text-muted small">Seleccione un elemento</p>';
    }
}

function duplicarElemento(id) {
    const elemento = estructura.find(e => e.id === id);
    if (elemento) {
        elementoIdCounter++;
        const nuevoId = `element-${elementoIdCounter}`;
        const copia = {
            ...elemento,
            id: nuevoId,
            orden: estructura.length
        };
        estructura.push(copia);
        renderizarElemento(copia);
    }
}

function moverArriba(id) {
    const index = estructura.findIndex(e => e.id === id);
    if (index > 0) {
        [estructura[index], estructura[index - 1]] = [estructura[index - 1], estructura[index]];
        actualizarOrdenElementos();
        reordenarCanvas();
    }
}

function moverAbajo(id) {
    const index = estructura.findIndex(e => e.id === id);
    if (index < estructura.length - 1) {
        [estructura[index], estructura[index + 1]] = [estructura[index + 1], estructura[index]];
        actualizarOrdenElementos();
        reordenarCanvas();
    }
}

function reordenarCanvas() {
    const canvas = document.getElementById('report-canvas');
    const canvasContent = document.getElementById('canvas-content');
    
    // NO limpiar todo el canvas, solo limpiar el contenido de elementos
    if (canvasContent) {
        // Limpiar solo los elementos, no el canvas-content ni las líneas de márgenes
        canvasContent.querySelectorAll('.element-item').forEach(el => el.remove());
        // Re-renderizar elementos en el orden correcto
        estructura.forEach(e => renderizarElemento(e));
        // Volver a dibujar márgenes (por si se perdieron)
        dibujarMargenes();
    } else {
        // Si no existe canvas-content, recrear la estructura completa
        canvas.innerHTML = '<div class="drop-zone" id="canvas-drop-zone"></div><div id="canvas-content"></div>';
        const newCanvasContent = document.getElementById('canvas-content');
        estructura.forEach(e => {
            const div = renderizarElemento(e);
            if (div && newCanvasContent) {
                newCanvasContent.appendChild(div);
            }
        });
        // Volver a dibujar márgenes
        dibujarMargenes();
    }
    
    // Actualizar el orden basándose en el orden del array
    actualizarOrdenElementos();
}

function actualizarOrdenElementos() {
    // Actualizar el campo 'orden' de cada elemento basándose en su posición en el array
    estructura.forEach((elemento, index) => {
        elemento.orden = index;
    });
}

function actualizarOrdenDesdeDOM() {
    // Actualizar el orden basándose en el orden real del DOM
    const canvasContent = document.getElementById('canvas-content');
    const canvas = document.getElementById('report-canvas');
    const elementosDOM = (canvasContent || canvas).querySelectorAll('.element-item');
    const nuevaEstructura = [];
    
    console.log('🔍 actualizarOrdenDesdeDOM - Elementos en estructura:', estructura.length);
    console.log('🔍 actualizarOrdenDesdeDOM - Elementos en DOM:', elementosDOM.length);
    
    // Elementos encontrados en DOM
    elementosDOM.forEach(div => {
        const elemento = estructura.find(e => e.id === div.id);
        if (elemento) {
            nuevaEstructura.push(elemento);
        } else {
            console.warn('⚠️ Elemento en DOM no encontrado en estructura:', div.id);
        }
    });
    
    // Agregar elementos que no estén en el DOM (por si acaso)
    const elementosNoEnDOM = [];
    estructura.forEach(elemento => {
        if (!nuevaEstructura.find(e => e.id === elemento.id)) {
            nuevaEstructura.push(elemento);
            elementosNoEnDOM.push(elemento);
            console.warn('⚠️ Elemento en estructura no encontrado en DOM, agregado de todas formas:', elemento.id, elemento.tipo);
        }
    });
    
    if (elementosNoEnDOM.length > 0) {
        console.log('⚠️ Elementos no encontrados en DOM pero agregados:', elementosNoEnDOM.map(el => ({ id: el.id, tipo: el.tipo })));
    }
    
    // Verificar elementos de datos específicamente
    const elementosDatosEnNueva = nuevaEstructura.filter(el => ['protocolo-fecha', 'datos-paciente', 'datos-medico', 'datos-paciente-medico'].includes(el.tipo));
    console.log('🔍 Elementos de datos en nueva estructura:', elementosDatosEnNueva.length, elementosDatosEnNueva.map(el => ({ tipo: el.tipo, id: el.id })));
    
    estructura = nuevaEstructura;
    actualizarOrdenElementos();
}

function configurarDragReordenamiento(elemento) {
    elemento.addEventListener('dragstart', (e) => {
        elemento.classList.add('dragging');
    });
    
    elemento.addEventListener('dragend', (e) => {
        elemento.classList.remove('dragging');
        // Actualizar orden después de soltar
        actualizarOrdenDesdeDOM();
    });
    
    elemento.addEventListener('dragover', (e) => {
        e.preventDefault();
        const canvasContent = document.getElementById('canvas-content');
        const targetContainer = canvasContent || document.getElementById('report-canvas');
        const afterElement = getDragAfterElement(targetContainer, e.clientY);
        if (afterElement == null) {
            targetContainer.appendChild(elemento);
        } else {
            targetContainer.insertBefore(elemento, afterElement);
        }
    });
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.element-item:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function cargarEstructuraExistente() {
    // Asegurar que estructura sea un array
    if (!Array.isArray(estructura)) {
        console.warn('Estructura no es un array, inicializando como array vacío');
        estructura = [];
    }
    
    if (estructura && estructura.length > 0) {
        const canvas = document.getElementById('report-canvas');
        const dropZone = document.querySelector('#canvas-drop-zone');
        
        // Eliminar el mensaje inicial si existe
        if (dropZone) {
            if (dropZone.querySelector('.text-center')) {
                dropZone.remove();
            }
        }
        
        // Encontrar el máximo ID para el contador
        estructura.forEach(e => {
            if (e && e.id && e.id.startsWith('element-')) {
                const num = parseInt(e.id.split('-')[1]);
                if (!isNaN(num) && num > elementoIdCounter) {
                    elementoIdCounter = num;
                }
            }
        });
        
        // Renderizar todos los elementos y asegurar que seccion_codigo esté presente
        estructura.forEach(e => {
            if (e) {
                // Si es una sección y no tiene seccion_codigo, intentar deducirlo del contenido
                if (e.tipo === 'seccion' && !e.seccion_codigo) {
                    const mapeoSecciones = {
                        'DATOS CLÍNICOS': 'DATOS_CLINICOS',
                        'MATERIAL REMITIDO': 'MATERIAL_REMITIDO',
                        'DESCRIPCIÓN MACROSCÓPICA': 'DESCRIPCION_MACROSCOPICA',
                        'DESCRIPCIÓN MICROSCÓPICA': 'DESCRIPCION_MICROSCOPICA',
                        'DIAGNÓSTICO': 'DIAGNOSTICO',
                        'EXTENDIDO': 'EXTENDIDO',
                        'DESCRIPCIÓN CITOLÓGICA': 'CELULAS_CONFORMACION',
                        'Junto a': 'CELULAS_JUNTO_A',
                        'COMPONENTE INFLAMATORIO': 'COMP_INFLAMATORIO',
                        'Flora': 'FLORA'
                    };
                    const contenido = e.contenido || '';
                    for (const [nombre, codigo] of Object.entries(mapeoSecciones)) {
                        if (contenido.includes(nombre) || nombre.includes(contenido)) {
                            e.seccion_codigo = codigo;
                            break;
                        }
                    }
                }
                renderizarElemento(e);
            }
        });
    }
    
    // Dibujar márgenes después de cargar la estructura
    setTimeout(() => {
        dibujarMargenes();
        actualizarRegla();
        actualizarReglaVertical();
    }, 300);
}

function cambiarTamanoPapel(tamano) {
    const canvas = document.getElementById('report-canvas');
    const personalizadoDiv = document.getElementById('tamano-personalizado');
    
    canvas.setAttribute('data-tamano', tamano);
    
    if (tamano === 'personalizado') {
        personalizadoDiv.style.display = 'block';
        aplicarTamanoPersonalizado();
    } else {
        personalizadoDiv.style.display = 'none';
        // Restablecer dimensiones estándar
        canvas.style.width = '';
        canvas.style.height = '';
        canvas.style.aspectRatio = '';
        
        if (tamano === 'A4') {
            canvas.style.width = '210mm';
            canvas.style.height = '297mm';
            canvas.style.aspectRatio = '210 / 297';
        } else if (tamano === 'Letter') {
            canvas.style.width = '216mm';
            canvas.style.height = '279mm';
            canvas.style.aspectRatio = '216 / 279';
        } else if (tamano === 'Legal') {
            canvas.style.width = '216mm';
            canvas.style.height = '356mm';
            canvas.style.aspectRatio = '216 / 356';
        }
    }
    
    // Guardar en configuración
    const config = obtenerConfiguracionActual();
    if (!config.impresion) config.impresion = {};
    config.impresion.tamaño_papel = tamano;
    guardarConfiguracionTemporal(config);
    
    // Redibujar márgenes después de cambiar tamaño
    setTimeout(() => {
        dibujarMargenes();
        actualizarRegla();
        actualizarReglaVertical();
    }, 100);
}

function aplicarTamanoPersonalizado() {
    const canvas = document.getElementById('report-canvas');
    const ancho = parseFloat(document.getElementById('ancho-personalizado').value) || 210;
    const alto = parseFloat(document.getElementById('alto-personalizado').value) || 297;
    
    canvas.style.width = ancho + 'mm';
    canvas.style.height = alto + 'mm';
    canvas.style.aspectRatio = ancho + ' / ' + alto;
    
    // Redibujar márgenes después de cambiar tamaño
    setTimeout(() => {
        dibujarMargenes();
        actualizarRegla();
        actualizarReglaVertical();
    }, 100);
    
    // Guardar dimensiones personalizadas
    const config = obtenerConfiguracionActual();
    if (!config.impresion) config.impresion = {};
    if (!config.impresion.dimensiones_personalizadas) config.impresion.dimensiones_personalizadas = {};
    config.impresion.dimensiones_personalizadas.ancho = ancho;
    config.impresion.dimensiones_personalizadas.alto = alto;
    guardarConfiguracionTemporal(config);
}

// Función helper para normalizar colores a formato completo (#rrggbb)
function normalizarColor(color) {
    if (!color || typeof color !== 'string') return '#000000';
    // Si el color tiene formato corto (#333, #000, etc.), expandirlo
    if (color.match(/^#[0-9a-fA-F]{3}$/)) {
        return '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
    }
    // Si ya tiene formato completo, devolverlo
    if (color.match(/^#[0-9a-fA-F]{6}$/)) {
        return color;
    }
    return '#000000'; // Valor por defecto si el formato no es válido
}

// Configuración global de secciones (se guarda en la configuración, no en elementos individuales)
let configSecciones = {{ configuracion.secciones|tojson if configuracion.secciones else '{}'|tojson }};

// Exponer configSecciones globalmente para que esté disponible en renderizarElemento
window.configSecciones = configSecciones;

// Normalizar colores en la configuración existente
if (configSecciones.color_fondo_titulo) configSecciones.color_fondo_titulo = normalizarColor(configSecciones.color_fondo_titulo);
if (configSecciones.titulo_color) configSecciones.titulo_color = normalizarColor(configSecciones.titulo_color);
if (configSecciones.color_vineta) configSecciones.color_vineta = normalizarColor(configSecciones.color_vineta);
if (configSecciones.contenido_color) configSecciones.contenido_color = normalizarColor(configSecciones.contenido_color);

function actualizarConfigSecciones(propiedad, valor) {
    if (!configSecciones) configSecciones = {};
    // Normalizar colores antes de guardar
    if (propiedad.includes('color') && valor) {
        valor = normalizarColor(valor);
    }
    configSecciones[propiedad] = valor;
    // IMPORTANTE: Actualizar la referencia global ANTES de re-renderizar
    // Esto asegura que renderizarElemento use los valores más recientes
    window.configSecciones = configSecciones;
    // También actualizar la variable local para consistencia
    configSecciones = window.configSecciones;
    console.log('Configuración de secciones actualizada:', propiedad, '=', valor);
    console.log('configSecciones completo:', JSON.stringify(configSecciones, null, 2));
    
    // Re-renderizar todas las secciones para aplicar los cambios (si es una propiedad de título o contenido)
    const propiedadesTitulo = ['titulo_fuente', 'titulo_tamano', 'titulo_color', 'titulo_alineacion', 'titulo_negrita', 'titulo_cursiva', 'color_fondo_titulo'];
    const propiedadesContenido = ['contenido_fuente', 'contenido_tamano', 'contenido_color', 'alineacion_contenido', 'contenido_negrita', 'contenido_cursiva', 'indentacion', 'mostrar_vinetas', 'color_vineta'];
    
    if (propiedadesTitulo.includes(propiedad) || propiedadesContenido.includes(propiedad)) {
        console.log('Re-renderizando secciones por cambio en:', propiedad, 'Valor:', valor);
        console.log('configSecciones actual:', configSecciones);
        
        const idSeleccionado = elementoSeleccionado; // Guardar el elemento seleccionado
        estructura.forEach(elemento => {
            if (elemento.tipo === 'seccion') {
                const div = document.getElementById(elemento.id);
                if (div) {
                    // Preservar posición en el DOM
                    const parent = div.parentElement;
                    const nextSibling = div.nextSibling;
                    div.remove();
                    
                    // Re-renderizar con la nueva configuración
                    const nuevoDiv = renderizarElemento(elemento);
                    if (parent && nuevoDiv) {
                        if (nextSibling) {
                            parent.insertBefore(nuevoDiv, nextSibling);
                        } else {
                            parent.appendChild(nuevoDiv);
                        }
                        
                        // Los estilos ya están aplicados directamente en el HTML generado por renderizarElemento
                        // No necesitamos aplicar estilos adicionales aquí
                    }
                }
            }
        });
        
        // Reseleccionar el elemento para mostrar los controles inline actualizados
        if (idSeleccionado) {
            setTimeout(() => {
                seleccionarElemento(idSeleccionado);
            }, 50);
        }
    }
}

function actualizarEstadoBotonFormato(checkbox, button) {
    if (!checkbox || !button) return;
    if (checkbox.checked) {
        button.classList.remove('btn-outline-secondary');
        button.classList.add('btn-primary');
    } else {
        button.classList.remove('btn-primary');
        button.classList.add('btn-outline-secondary');
    }
}

function manejarCambioFormato(checkbox, propiedad, buttonId) {
    actualizarConfigSecciones(propiedad, checkbox.checked);
    const button = document.getElementById(buttonId);
    actualizarEstadoBotonFormato(checkbox, button);
}

function toggleBotonFormato(checkboxId) {
    const checkbox = document.getElementById(checkboxId);
    if (!checkbox) return;
    checkbox.checked = !checkbox.checked;
    checkbox.dispatchEvent(new Event('change', { bubbles: true }));
}

function inicializarBotonesFormatoGlobal() {
    [
        ['config-titulo-negrita', 'btn-titulo-negrita'],
        ['config-titulo-cursiva', 'btn-titulo-cursiva'],
        ['config-contenido-negrita', 'btn-contenido-negrita'],
        ['config-contenido-cursiva', 'btn-contenido-cursiva']
    ].forEach(([checkboxId, buttonId]) => {
        const checkbox = document.getElementById(checkboxId);
        const button = document.getElementById(buttonId);
        if (!checkbox || !button) return;
        actualizarEstadoBotonFormato(checkbox, button);
        checkbox.addEventListener('change', () => actualizarEstadoBotonFormato(checkbox, button));
    });
}

function actualizarMargenesHoja() {
    // Esta función se llama cuando se cambian los márgenes de la hoja
    // Los valores se guardarán automáticamente al guardar el diseño
    dibujarMargenes();
    actualizarRegla();
    actualizarReglaVertical();
    console.log('Márgenes de la hoja actualizados');
}

// Función para actualizar la regla horizontal en píxeles
function actualizarRegla() {
    const canvas = document.getElementById('report-canvas');
    const ruler = document.getElementById('ruler-horizontal');
    const rulerScale = document.getElementById('ruler-scale');
    
    if (!canvas || !ruler || !rulerScale) return;
    
    // 1. Obtener el ancho de la página (canvas) en píxeles renderizados (con zoom)
    const canvasRect = canvas.getBoundingClientRect();
    const anchoPaginaRenderizado = canvasRect.width;
    
    // Obtener el ancho CSS del canvas (puede estar en mm)
    const computedStyle = window.getComputedStyle(canvas);
    let widthCSS = computedStyle.width;
    
    // Convertir mm a px (1mm ≈ 3.779527559px a 96 DPI)
    const mmToPx = 3.779527559;
    
    // Ancho de la página en píxeles REALES (sin zoom)
    let anchoPaginaRealPx;
    if (widthCSS.includes('mm')) {
        const mm = parseFloat(widthCSS);
        anchoPaginaRealPx = mm * mmToPx;
    } else {
        anchoPaginaRealPx = parseFloat(widthCSS);
    }
    
    // Obtener márgenes izquierdo y derecho
    const margenIzqInput = document.getElementById('config-margen-hoja-izquierdo');
    const margenDerInput = document.getElementById('config-margen-hoja-derecho');
    
    const margenIzq = parseInt(margenIzqInput ? margenIzqInput.value : 20) || 20;
    const margenDer = parseInt(margenDerInput ? margenDerInput.value : 20) || 20;
    
    // 2. Calcular cuánto debe medir la regla: ancho de página menos los dos márgenes laterales
    const margenIzqPx = margenIzq * mmToPx;
    const margenDerPx = margenDer * mmToPx;
    const anchoReglaRealPx = anchoPaginaRealPx - margenIzqPx - margenDerPx;
    
    // Calcular el zoom factor REAL basado en las dimensiones renderizadas vs reales del canvas
    // Esto es más preciso que usar zoomLevel directamente porque puede haber otras transformaciones
    const zoomFactorReal = anchoPaginaRenderizado / anchoPaginaRealPx;
    
    // Ancho de la regla renderizado (con zoom real)
    const anchoReglaRenderizado = anchoReglaRealPx * zoomFactorReal;
    
    console.log('🔍 Zoom Factor:', {
        zoomLevel: zoomLevel,
        zoomFactorCalculado: zoomLevel / 100,
        zoomFactorReal: zoomFactorReal,
        anchoPaginaRealPx: anchoPaginaRealPx,
        anchoPaginaRenderizado: anchoPaginaRenderizado
    });
    
    // 3. Ubicar las líneas de margen para posicionar la regla
    const lineasMargen = canvas.querySelectorAll('.margen-linea.vertical');
    let lineaIzq = null, lineaDer = null;
    
    // Identificar línea izquierda y derecha
    lineasMargen.forEach(linea => {
        const lineaRect = linea.getBoundingClientRect();
        const canvasLeft = canvasRect.left;
        // La línea izquierda está más cerca del borde izquierdo del canvas
        if (!lineaIzq || lineaRect.left < lineaIzq.getBoundingClientRect().left) {
            lineaIzq = linea;
        }
        // La línea derecha está más cerca del borde derecho del canvas
        if (!lineaDer || lineaRect.left > lineaDer.getBoundingClientRect().left) {
            lineaDer = linea;
        }
    });
    
    // Obtener la posición del canvas dentro del wrapper
    const canvasWrapper = canvas.closest('.canvas-wrapper');
    const wrapperRect = canvasWrapper ? canvasWrapper.getBoundingClientRect() : canvasRect;
    const canvasOffsetY = canvasRect.top - wrapperRect.top;
    
    // 4. Si encontré las líneas de margen, usar sus posiciones exactas
    let posicionInicioRegla;
    
    if (lineaIzq && lineaDer) {
        // Usar getBoundingClientRect para obtener posiciones exactas renderizadas
        const lineaIzqRect = lineaIzq.getBoundingClientRect();
        const lineaDerRect = lineaDer.getBoundingClientRect();
        
        // Posición del cero de la regla = posición del margen izquierdo relativo al wrapper
        posicionInicioRegla = lineaIzqRect.left - wrapperRect.left;
        
        // Verificar que el ancho de la regla coincida con la distancia entre márgenes
        const anchoReglaCalculado = lineaDerRect.left - lineaIzqRect.left;
        
        // Validar que los valores sean válidos
        if (anchoReglaCalculado <= 0 || isNaN(anchoReglaCalculado)) {
            console.error('❌ Error: anchoReglaCalculado inválido:', anchoReglaCalculado);
            // Usar el ancho renderizado teórico como fallback
            ruler.style.width = anchoReglaRenderizado + 'px';
        } else {
            // IMPORTANTE: El ancho de la regla DEBE ser exactamente la distancia entre márgenes
            // Este es el ancho visual que el usuario ve
            ruler.style.width = anchoReglaCalculado + 'px';
            console.log('✅ Ancho de regla establecido desde líneas de margen:', {
                anchoReglaCalculado: anchoReglaCalculado,
                lineaIzqLeft: lineaIzqRect.left,
                lineaDerLeft: lineaDerRect.left,
                diferencia: lineaDerRect.left - lineaIzqRect.left
            });
        }
        
        if (isNaN(posicionInicioRegla) || posicionInicioRegla < -10000) {
            console.error('❌ Error: posicionInicioRegla inválida:', posicionInicioRegla);
            // Fallback: usar posición del canvas
            posicionInicioRegla = canvasRect.left - wrapperRect.left;
        }
        
        console.log('📏 Cálculos de la regla:', {
            anchoPaginaRealPx: anchoPaginaRealPx,
            anchoPaginaRenderizado: anchoPaginaRenderizado,
            margenIzq: margenIzq + 'mm (' + margenIzqPx + 'px)',
            margenDer: margenDer + 'mm (' + margenDerPx + 'px)',
            anchoReglaRealPx: anchoReglaRealPx,
            anchoReglaRenderizado: anchoReglaRenderizado,
            anchoReglaCalculado: anchoReglaCalculado,
            zoomFactorReal: zoomFactorReal,
            posicionInicioRegla: posicionInicioRegla,
            rulerWidth: ruler.style.width
        });
    } else {
        // Fallback: calcular desde márgenes si las líneas no existen
        const canvasOffsetX = canvasRect.left - wrapperRect.left;
        const margenIzqRenderizado = margenIzqPx * zoomFactorReal;
        posicionInicioRegla = canvasOffsetX + margenIzqRenderizado;
        ruler.style.width = anchoReglaRenderizado + 'px';
        
        // Esperar a que se dibujen los márgenes y volver a calcular
        setTimeout(() => {
            actualizarRegla();
            actualizarReglaVertical();
        }, 100);
    }
    
    // Aplicar posición de la regla (validar antes de aplicar)
    if (!isNaN(posicionInicioRegla) && posicionInicioRegla > -10000) {
        ruler.style.left = posicionInicioRegla + 'px';
    } else {
        console.error('❌ Error: posicionInicioRegla inválida, usando fallback');
        ruler.style.left = (canvasRect.left - wrapperRect.left) + 'px';
    }
    
    if (!isNaN(canvasOffsetY) && canvasOffsetY > -10000) {
        ruler.style.top = (canvasOffsetY - 30) + 'px'; // 30px es la altura de la regla
    } else {
        console.error('❌ Error: canvasOffsetY inválido, usando fallback');
        ruler.style.top = '0px';
    }
    
    // Asegurar que la regla sea visible
    if (!ruler.style.width || parseFloat(ruler.style.width) <= 0) {
        console.error('❌ Error: ancho de regla inválido, usando fallback');
        ruler.style.width = anchoReglaRenderizado + 'px';
    }
    
    // Asegurar que la regla sea visible
    ruler.style.display = 'block';
    ruler.style.visibility = 'visible';
    ruler.style.opacity = '1';
    
    // El ancho visual de la regla = distancia entre márgenes (ya calculado arriba)
    const anchoReglaVisual = parseFloat(ruler.style.width) || anchoReglaRenderizado;
    
    // La escala debe mostrar de 0px a anchoReglaRealPx (642px)
    // Este es el ancho REAL del contenido entre márgenes
    // Usar el valor exacto, no redondear, para que la última marca esté exactamente al final
    const maxPxEscala = anchoReglaRealPx; // 642.5px (valor exacto)
    
    // El ancho del ruler-scale debe ser igual al ancho visual de la regla
    rulerScale.style.width = anchoReglaVisual + 'px';
    
    console.log('📐 Configuración de la regla:', {
        anchoReglaRealPx: anchoReglaRealPx, // 642.5px - ancho REAL entre márgenes
        anchoReglaVisual: anchoReglaVisual, // Ancho visual de la regla (distancia entre márgenes renderizada)
        maxPxEscala: maxPxEscala, // 650px - máximo valor de la escala
        escala: '0px a ' + anchoReglaRealPx.toFixed(1) + 'px', // Rango numérico: 0 a 642px
        formulaPosicion: 'pxPosition = (px / ' + anchoReglaRealPx.toFixed(1) + ') * ' + anchoReglaVisual.toFixed(1),
        ejemploUltimaMarca: '650px -> posición = (650 / ' + anchoReglaRealPx.toFixed(1) + ') * ' + anchoReglaVisual.toFixed(1) + ' = ' + ((650 / anchoReglaRealPx) * anchoReglaVisual).toFixed(1) + 'px'
    });
    
    console.log('📍 Regla posicionada:', {
        left: ruler.style.left,
        top: ruler.style.top,
        width: ruler.style.width,
        anchoReglaVisual: anchoReglaVisual,
        ultimaMarcaPosicion: (maxPxEscala / anchoReglaRealPx) * anchoReglaVisual,
        display: ruler.style.display
    });
    
    // Limpiar la regla anterior
    rulerScale.innerHTML = '';
    
    // 5. Generar marcas basadas en el ancho REAL de la regla (sin zoom)
    // IMPORTANTE: Las marcas representan píxeles REALES del área de contenido (0 a 642px)
    // pero se posicionan proporcionalmente dentro del ancho visual de la regla
    const stepMicro = 10; // Marcas cada 10px
    const stepMinor = 50;  // Marcas cada 50px
    const stepMajor = 100; // Marcas cada 100px
    
    // IMPORTANTE: La escala SIEMPRE muestra de 0 a anchoReglaRealPx (642px), INDEPENDIENTE del zoom
    // Las marcas se posicionan proporcionalmente dentro del ancho visual de la regla
    // Si el zoom es bajo, las marcas se verán más juntas. Si es alto, más separadas.
    // Pero siempre mostrarán el rango completo de 0 a 642px
    
    console.log('🔢 Generando escala (siempre 0 a ' + anchoReglaRealPx.toFixed(1) + 'px):', {
        anchoReglaRealPx: anchoReglaRealPx, // 642.5px - MÁXIMO de la escala (fijo)
        anchoReglaVisual: anchoReglaVisual, // Ancho visual de la regla (coincide con espacio entre márgenes)
        zoomFactorReal: zoomFactorReal,
        maxPxEscala: maxPxEscala, // 650px - máximo de la escala (siempre el mismo)
        totalMarcasEsperadas: (maxPxEscala / stepMicro) + 1, // 66 marcas (0 a 650px) - SIEMPRE
        ultimaMarcaEsperada: maxPxEscala + 'px' // 650px - la última marca debe mostrar esto
    });
    
    // Generar TODAS las marcas hasta el máximo de la escala (anchoReglaRealPx = 642px)
    // Las marcas se posicionan proporcionalmente dentro del ancho visual de la regla
    // Fórmula: posición = (px / anchoReglaRealPx) * anchoReglaVisual
    let marcasGeneradas = 0;
    let ultimaMarcaGenerada = 0;
    
    // Generar marcas hasta maxPxEscala (642.5px)
    // IMPORTANTE: Generar marcas cada 10px desde 0 hasta el último múltiplo de 10 antes de 642.5px (640px)
    // Luego agregar una marca final en 642.5px
    // Las marcas se posicionan proporcionalmente dentro del ancho visual de la regla
    // pero los valores mostrados siempre son de 0 a 642.5px
    let px = 0;
    const ultimoMultiploDe10 = Math.floor(maxPxEscala / stepMicro) * stepMicro; // 640px
    
    // Generar marcas normales hasta 640px
    while (px <= ultimoMultiploDe10) {
        // Calcular la posición visual proporcional dentro del ancho visual de la regla
        // Fórmula: posición = (px / 642.5px) * anchoVisualRegla
        const pxPosition = (px / anchoReglaRealPx) * anchoReglaVisual;
        
        let markClass = 'micro';
        let showLabel = false;
        
        if (px % stepMajor === 0) {
            markClass = 'major';
            showLabel = true;
        } else if (px % stepMinor === 0) {
            markClass = 'minor';
        }
        
        const mark = document.createElement('div');
        mark.className = `ruler-mark ${markClass}`;
        mark.style.left = pxPosition + 'px';
        
        if (showLabel) {
            const label = document.createElement('span');
            label.className = 'ruler-label';
            // Mostrar el valor real en píxeles (0 a 640px)
            label.textContent = px + 'px';
            // IMPORTANTE: La etiqueta está dentro de .ruler-mark, que tiene position: absolute
            // La marca está en pxPosition, así que la etiqueta debe estar relativa a la marca
            // Estimar el ancho de la etiqueta (aproximadamente 30-40px para "400px", "500px", etc.)
            const anchoEstimadoLabel = 35; // px
            let labelLeft = 3; // Offset desde la marca
            
            // Si la marca + el ancho de la etiqueta se saldría del contenedor, ajustar
            if (pxPosition + anchoEstimadoLabel > anchoReglaVisual) {
                // Mover la etiqueta hacia la izquierda para que quepa
                labelLeft = anchoReglaVisual - pxPosition - anchoEstimadoLabel + 3;
                // Asegurar que no sea negativo (mínimo 3px desde la marca)
                if (labelLeft < 3) {
                    labelLeft = 3;
                }
            }
            
            label.style.left = labelLeft + 'px';
            mark.appendChild(label);
        }
        
        rulerScale.appendChild(mark);
        marcasGeneradas++;
        ultimaMarcaGenerada = px;
        px += stepMicro;
    }
    
    // Agregar la marca final en 642.5px exactamente al final de la regla
    const ultimaMarca = document.createElement('div');
    ultimaMarca.className = 'ruler-mark major';
    ultimaMarca.style.left = anchoReglaVisual + 'px'; // Exactamente al final
    
    const ultimaLabel = document.createElement('span');
    ultimaLabel.className = 'ruler-label';
    ultimaLabel.textContent = Math.round(anchoReglaRealPx) + 'px'; // 642px o 643px
    // IMPORTANTE: La última marca está en anchoReglaVisual (al final del contenedor)
    // La etiqueta está dentro de la marca, así que su left es relativo a la marca
    // Estimar el ancho del label (aproximadamente 35-40px para "642px")
    const anchoEstimadoUltimaLabel = 40;
    // La marca está en anchoReglaVisual, así que la etiqueta debe estar hacia la izquierda
    // para que quepa dentro del contenedor. Calcular la posición relativa a la marca:
    // Si la marca está en 320px y el label tiene 40px de ancho, el label debe estar en
    // 320px - 40px = 280px relativo al contenedor, o sea -40px relativo a la marca
    const ultimaLabelLeft = -(anchoEstimadoUltimaLabel - 3); // -37px relativo a la marca
    ultimaLabel.style.left = ultimaLabelLeft + 'px';
    ultimaMarca.appendChild(ultimaLabel);
    
    rulerScale.appendChild(ultimaMarca);
    marcasGeneradas++;
    ultimaMarcaGenerada = anchoReglaRealPx;
    
    // Verificar todas las marcas generadas
    const todasLasMarcas = Array.from(rulerScale.querySelectorAll('.ruler-mark'));
    const todasLasEtiquetas = Array.from(rulerScale.querySelectorAll('.ruler-label'));
    const valoresEtiquetas = todasLasEtiquetas.map(label => label.textContent);
    
    // Obtener posiciones de las etiquetas para verificar si están dentro del contenedor
    const etiquetasConPosicion = todasLasEtiquetas.map(label => {
        const mark = label.closest('.ruler-mark');
        return {
            texto: label.textContent,
            posicionMarca: mark ? parseFloat(mark.style.left) : 0,
            posicionLabel: parseFloat(label.style.left)
        };
    });
    
    console.log('📊 Marcas generadas en el bucle:', {
        marcasGeneradas: marcasGeneradas,
        ultimaMarcaGenerada: ultimaMarcaGenerada + 'px',
        maxPxEscala: maxPxEscala + 'px',
        ultimoMultiploDe10: ultimoMultiploDe10 + 'px',
        anchoReglaVisual: anchoReglaVisual + 'px',
        totalMarcasEnDOM: todasLasMarcas.length,
        totalEtiquetasEnDOM: todasLasEtiquetas.length,
        primeraEtiqueta: valoresEtiquetas[0] || 'N/A',
        ultimaEtiqueta: valoresEtiquetas[valoresEtiquetas.length - 1] || 'N/A',
        todasLasEtiquetas: valoresEtiquetas.join(', '),
        etiquetasConPosicion: etiquetasConPosicion.filter(e => parseFloat(e.texto) % 100 === 0) // Solo múltiplos de 100
    });
    
    // Verificar la última marca generada visualmente
    const ultimaMarcaElemento = rulerScale.querySelector('.ruler-mark:last-child');
    const ultimaMarcaPosicionReal = ultimaMarcaElemento ? parseFloat(ultimaMarcaElemento.style.left) : 0;
    const ultimaMarcaLabel = ultimaMarcaElemento ? ultimaMarcaElemento.querySelector('.ruler-label') : null;
    const ultimaMarcaValor = ultimaMarcaLabel ? ultimaMarcaLabel.textContent : 'N/A';
    
    const totalMarcas = rulerScale.children.length;
    
    console.log('✅ Regla actualizada:', {
        anchoReglaRealPx: anchoReglaRealPx, // 642.5px - MÁXIMO de la escala
        anchoReglaVisual: anchoReglaVisual, // Ancho visual de la regla (distancia entre márgenes)
        rulerWidth: ruler.style.width, // Ancho CSS de la regla
        rulerScaleWidth: rulerScale.style.width, // Ancho CSS del scale
        zoomFactorReal: zoomFactorReal,
        zoomLevel: zoomLevel,
        totalMarcasGeneradas: totalMarcas,
        ultimaMarcaGenerada: ultimaMarcaGenerada, // Valor de px de la última marca generada
        ultimaMarcaValor: ultimaMarcaValor, // Valor mostrado en la última marca (ej: "642px")
        maxPxCalculado: maxPxEscala,
        ultimaMarcaPosicionCalculada: anchoReglaVisual.toFixed(1) + 'px',
        ultimaMarcaPosicionReal: ultimaMarcaPosicionReal.toFixed(1) + 'px',
        esperado: 'La última marca debe mostrar ' + Math.round(anchoReglaRealPx) + 'px y estar en posición ' + anchoReglaVisual.toFixed(1) + 'px',
        coincide: Math.abs(ultimaMarcaPosicionReal - anchoReglaVisual) < 1
    });
    
    // Verificar que la última marca sea correcta
    if (ultimaMarcaGenerada < anchoReglaRealPx - 1) {
        console.error('❌ ERROR: La última marca es', ultimaMarcaGenerada + 'px, pero debería ser', anchoReglaRealPx.toFixed(1) + 'px');
    }
}

function actualizarReglaVertical() {
    const canvas = document.getElementById('report-canvas');
    const ruler = document.getElementById('ruler-vertical');
    const rulerScale = document.getElementById('ruler-scale-vertical');
    
    if (!canvas || !ruler || !rulerScale) return;
    
    // 1. Obtener el alto de la página (canvas) en píxeles renderizados (con zoom)
    const canvasRect = canvas.getBoundingClientRect();
    const altoPaginaRenderizado = canvasRect.height;
    
    // Obtener el alto CSS del canvas (puede estar en mm)
    const computedStyle = window.getComputedStyle(canvas);
    let heightCSS = computedStyle.height;
    
    // Convertir mm a px (1mm ≈ 3.779527559px a 96 DPI)
    const mmToPx = 3.779527559;
    
    // Alto de la página en píxeles REALES (sin zoom)
    let altoPaginaRealPx;
    if (heightCSS.includes('mm')) {
        const mm = parseFloat(heightCSS);
        altoPaginaRealPx = mm * mmToPx;
    } else {
        altoPaginaRealPx = parseFloat(heightCSS);
    }
    
    // Obtener márgenes superior e inferior
    const margenSupInput = document.getElementById('config-margen-hoja-superior');
    const margenInfInput = document.getElementById('config-margen-hoja-inferior');
    
    const margenSup = parseInt(margenSupInput ? margenSupInput.value : 20) || 20;
    const margenInf = parseInt(margenInfInput ? margenInfInput.value : 20) || 20;
    
    // 2. Calcular cuánto debe medir la regla: alto de página menos los dos márgenes verticales
    const margenSupPx = margenSup * mmToPx;
    const margenInfPx = margenInf * mmToPx;
    const altoReglaRealPx = altoPaginaRealPx - margenSupPx - margenInfPx;
    
    // Calcular el zoom factor REAL basado en las dimensiones renderizadas vs reales del canvas
    const zoomFactorReal = altoPaginaRenderizado / altoPaginaRealPx;
    
    // Alto de la regla renderizado (con zoom real)
    const altoReglaRenderizado = altoReglaRealPx * zoomFactorReal;
    
    // 3. Ubicar las líneas de margen para posicionar la regla
    const lineasMargen = canvas.querySelectorAll('.margen-linea.horizontal');
    let lineaSup = null, lineaInf = null;
    
    // Identificar línea superior e inferior
    lineasMargen.forEach(linea => {
        const lineaRect = linea.getBoundingClientRect();
        // La línea superior está más cerca del borde superior del canvas
        if (!lineaSup || lineaRect.top < lineaSup.getBoundingClientRect().top) {
            lineaSup = linea;
        }
        // La línea inferior está más cerca del borde inferior del canvas
        if (!lineaInf || lineaRect.top > lineaInf.getBoundingClientRect().top) {
            lineaInf = linea;
        }
    });
    
    // Obtener la posición del canvas dentro del wrapper
    const canvasWrapper = canvas.closest('.canvas-wrapper');
    const wrapperRect = canvasWrapper ? canvasWrapper.getBoundingClientRect() : canvasRect;
    const canvasOffsetX = canvasRect.left - wrapperRect.left;
    
    // 4. Si encontré las líneas de margen, usar sus posiciones exactas
    let posicionInicioRegla;
    
    if (lineaSup && lineaInf) {
        // Usar getBoundingClientRect para obtener posiciones exactas renderizadas
        const lineaSupRect = lineaSup.getBoundingClientRect();
        const lineaInfRect = lineaInf.getBoundingClientRect();
        
        // Posición del cero de la regla = posición del margen superior relativo al wrapper
        posicionInicioRegla = lineaSupRect.top - wrapperRect.top;
        
        // Verificar que el alto de la regla coincida con la distancia entre márgenes
        const altoReglaCalculado = lineaInfRect.top - lineaSupRect.top;
        
        // Validar que los valores sean válidos
        if (altoReglaCalculado <= 0 || isNaN(altoReglaCalculado)) {
            console.error('❌ Error: altoReglaCalculado inválido:', altoReglaCalculado);
            ruler.style.height = altoReglaRenderizado + 'px';
        } else {
            ruler.style.height = altoReglaCalculado + 'px';
        }
        
        if (isNaN(posicionInicioRegla) || posicionInicioRegla < -10000) {
            console.error('❌ Error: posicionInicioRegla inválida:', posicionInicioRegla);
            posicionInicioRegla = canvasRect.top - wrapperRect.top;
        }
    } else {
        // Fallback: calcular desde márgenes si las líneas no existen
        const canvasOffsetY = canvasRect.top - wrapperRect.top;
        const margenSupRenderizado = margenSupPx * zoomFactorReal;
        posicionInicioRegla = canvasOffsetY + margenSupRenderizado;
        ruler.style.height = altoReglaRenderizado + 'px';
        
        // Esperar a que se dibujen los márgenes y volver a calcular
        setTimeout(() => actualizarReglaVertical(), 100);
    }
    
    // Aplicar posición de la regla (validar antes de aplicar)
    if (!isNaN(posicionInicioRegla) && posicionInicioRegla > -10000) {
        ruler.style.top = posicionInicioRegla + 'px';
    } else {
        console.error('❌ Error: posicionInicioRegla inválida, usando fallback');
        ruler.style.top = (canvasRect.top - wrapperRect.top) + 'px';
    }
    
    if (!isNaN(canvasOffsetX) && canvasOffsetX > -10000) {
        ruler.style.left = (canvasOffsetX - 30) + 'px'; // 30px es el ancho de la regla
    } else {
        console.error('❌ Error: canvasOffsetX inválido, usando fallback');
        ruler.style.left = '0px';
    }
    
    // Asegurar que la regla sea visible
    if (!ruler.style.height || parseFloat(ruler.style.height) <= 0) {
        console.error('❌ Error: alto de regla inválido, usando fallback');
        ruler.style.height = altoReglaRenderizado + 'px';
    }
    
    ruler.style.display = 'block';
    ruler.style.visibility = 'visible';
    ruler.style.opacity = '1';
    
    // El alto visual de la regla = distancia entre márgenes (ya calculado arriba)
    const altoReglaVisual = parseFloat(ruler.style.height) || altoReglaRenderizado;
    
    // La escala debe mostrar de 0px a altoReglaRealPx
    const maxPxEscala = altoReglaRealPx;
    
    // El alto del ruler-scale debe ser igual al alto visual de la regla
    rulerScale.style.height = altoReglaVisual + 'px';
    
    // Limpiar la regla anterior
    rulerScale.innerHTML = '';
    
    // 5. Generar marcas basadas en el alto REAL de la regla (sin zoom)
    const stepMicro = 10; // Marcas cada 10px
    const stepMinor = 50;  // Marcas cada 50px
    const stepMajor = 100; // Marcas cada 100px
    
    let px = 0;
    const ultimoMultiploDe10 = Math.floor(maxPxEscala / stepMicro) * stepMicro;
    
    // Generar marcas normales hasta el último múltiplo de 10
    while (px <= ultimoMultiploDe10) {
        // Calcular la posición visual proporcional dentro del alto visual de la regla
        const pxPosition = (px / altoReglaRealPx) * altoReglaVisual;
        
        let markClass = 'micro';
        let showLabel = false;
        
        if (px % stepMajor === 0) {
            markClass = 'major';
            showLabel = true;
        } else if (px % stepMinor === 0) {
            markClass = 'minor';
        }
        
        const mark = document.createElement('div');
        mark.className = `ruler-mark-vertical ${markClass}`;
        mark.style.top = pxPosition + 'px';
        
        if (showLabel) {
            const label = document.createElement('span');
            label.className = 'ruler-label-vertical';
            label.textContent = px + 'px';
            // Posicionar la etiqueta centrada en la marca pero desplazada a la derecha
            // para evitar superposición con la línea
            label.style.left = '8px'; // Separar de la línea de la marca
            // Centrar verticalmente la etiqueta en la posición de la marca
            // Como la etiqueta está rotada, necesitamos ajustar el top considerando el ancho rotado
            const anchoLabelRotado = 30; // Ancho de la etiqueta después de rotar
            label.style.top = (pxPosition - anchoLabelRotado / 2) + 'px';
            // Ajustar si se sale del contenedor
            if (pxPosition - anchoLabelRotado / 2 < 0) {
                label.style.top = '0px';
            } else if (pxPosition + anchoLabelRotado / 2 > altoReglaVisual) {
                label.style.top = (altoReglaVisual - anchoLabelRotado) + 'px';
            }
            mark.appendChild(label);
        }
        
        rulerScale.appendChild(mark);
        px += stepMicro;
    }
    
    // Agregar la marca final al final de la regla
    const ultimaMarca = document.createElement('div');
    ultimaMarca.className = 'ruler-mark-vertical major';
    ultimaMarca.style.top = altoReglaVisual + 'px';
    
    const ultimaLabel = document.createElement('span');
    ultimaLabel.className = 'ruler-label-vertical';
    ultimaLabel.textContent = Math.round(altoReglaRealPx) + 'px';
    // Posicionar la etiqueta centrada en la última marca
    ultimaLabel.style.left = '8px';
    const anchoLabelRotado = 30;
    if (altoReglaVisual - anchoLabelRotado < 0) {
        ultimaLabel.style.top = '0px';
    } else {
        ultimaLabel.style.top = (altoReglaVisual - anchoLabelRotado) + 'px';
    }
    ultimaMarca.appendChild(ultimaLabel);
    
    rulerScale.appendChild(ultimaMarca);
}

function dibujarMargenes() {
    // Eliminar líneas de márgenes existentes
    document.querySelectorAll('.margen-linea').forEach(linea => linea.remove());
    
    const canvas = document.getElementById('report-canvas');
    const canvasContent = document.getElementById('canvas-content');
    if (!canvas || !canvasContent) {
        console.log('Canvas o canvas-content no encontrado');
        return;
    }
    
    // Obtener valores de márgenes
    const margenSupInput = document.getElementById('config-margen-hoja-superior');
    const margenInfInput = document.getElementById('config-margen-hoja-inferior');
    const margenIzqInput = document.getElementById('config-margen-hoja-izquierdo');
    const margenDerInput = document.getElementById('config-margen-hoja-derecho');
    
    if (!margenSupInput || !margenInfInput || !margenIzqInput || !margenDerInput) {
        console.log('Inputs de márgenes no encontrados');
        return;
    }
    
    const margenSup = parseInt(margenSupInput.value || 20);
    const margenInf = parseInt(margenInfInput.value || 20);
    const margenIzq = parseInt(margenIzqInput.value || 20);
    const margenDer = parseInt(margenDerInput.value || 20);
    
    console.log('Dibujando márgenes:', { margenSup, margenInf, margenIzq, margenDer });
    
    // Convertir mm a px (1mm ≈ 3.779527559px a 96 DPI)
    const mmToPx = 3.779527559;
    
    // Obtener dimensiones del canvas completo (incluyendo padding)
    const canvasRect = canvas.getBoundingClientRect();
    const canvasWidthPx = canvasRect.width;
    const canvasHeightPx = canvasRect.height;
    
    // Los márgenes se calculan desde el BORDE del canvas (0 = borde, no padding)
    // Entonces si margen = 0, la línea está en el borde
    const supPx = margenSup * mmToPx;
    const infPx = margenInf * mmToPx;
    const izqPx = margenIzq * mmToPx;
    const derPx = margenDer * mmToPx;
    
    // Aplicar márgenes al contenedor de contenido
    canvasContent.style.padding = `${margenSup}mm ${margenDer}mm ${margenInf}mm ${margenIzq}mm`;
    
    console.log('Dimensiones canvas:', { canvasWidthPx, canvasHeightPx });
    console.log('Márgenes configurados (mm):', { margenSup, margenInf, margenIzq, margenDer });
    console.log('Posiciones líneas (px desde borde):', { supPx, infPx, izqPx, derPx });
    
    // Crear líneas de márgenes (marcan el área segura donde NO debe ir contenido)
    // Línea superior
    const lineaSup = document.createElement('div');
    lineaSup.className = 'margen-linea horizontal';
    lineaSup.style.top = supPx + 'px';
    lineaSup.style.left = izqPx + 'px';
    lineaSup.style.width = (canvasWidthPx - izqPx - derPx) + 'px';
    canvas.appendChild(lineaSup);
    
    // Línea inferior
    const lineaInf = document.createElement('div');
    lineaInf.className = 'margen-linea horizontal';
    lineaInf.style.bottom = infPx + 'px';
    lineaInf.style.left = izqPx + 'px';
    lineaInf.style.width = (canvasWidthPx - izqPx - derPx) + 'px';
    canvas.appendChild(lineaInf);
    
    // Línea izquierda
    const lineaIzq = document.createElement('div');
    lineaIzq.className = 'margen-linea vertical';
    lineaIzq.style.left = izqPx + 'px';
    lineaIzq.style.top = supPx + 'px';
    lineaIzq.style.height = (canvasHeightPx - supPx - infPx) + 'px';
    canvas.appendChild(lineaIzq);
    
    // Línea derecha
    const lineaDer = document.createElement('div');
    lineaDer.className = 'margen-linea vertical';
    lineaDer.style.right = derPx + 'px';
    lineaDer.style.top = supPx + 'px';
    lineaDer.style.height = (canvasHeightPx - supPx - infPx) + 'px';
    canvas.appendChild(lineaDer);
    
    console.log('Líneas de margen dibujadas y padding aplicado al contenido');
}

function obtenerConfiguracionActual() {
    // Esto podría leerse desde el servidor o mantenerse en memoria
    const config = {{ configuracion|tojson }};
    
    // Actualizar márgenes de la hoja desde los inputs
    if (!config.margenes) config.margenes = {};
    const margenSup = document.getElementById('config-margen-hoja-superior');
    const margenInf = document.getElementById('config-margen-hoja-inferior');
    const margenIzq = document.getElementById('config-margen-hoja-izquierdo');
    const margenDer = document.getElementById('config-margen-hoja-derecho');
    if (margenSup) config.margenes.superior = parseInt(margenSup.value) || 20;
    if (margenInf) config.margenes.inferior = parseInt(margenInf.value) || 20;
    if (margenIzq) config.margenes.izquierdo = parseInt(margenIzq.value) || 20;
    if (margenDer) config.margenes.derecho = parseInt(margenDer.value) || 20;
    
    // Actualizar configuración de secciones con los valores del panel
    if (!config.secciones) config.secciones = {};
    // Normalizar colores en configSecciones antes de asignar
    const configSeccionesNormalizado = {};
    for (const key in configSecciones) {
        if (key.includes('color') && configSecciones[key]) {
            configSeccionesNormalizado[key] = normalizarColor(configSecciones[key]);
        } else {
            configSeccionesNormalizado[key] = configSecciones[key];
        }
    }
    config.secciones = Object.assign(config.secciones, configSeccionesNormalizado);
    return config;
}

function guardarConfiguracionTemporal(config) {
    // Guardar temporalmente mientras se edita
    sessionStorage.setItem('disenio_config_temp', JSON.stringify(config));
}

function ajustarZoom(delta) {
    zoomLevel = Math.max(25, Math.min(200, zoomLevel + delta));
    aplicarZoom();
}

function resetearZoom() {
    zoomLevel = 100;
    aplicarZoom();
}

function aplicarZoom() {
    const canvas = document.getElementById('report-canvas');
    if (canvas) {
        canvas.style.transform = `scale(${zoomLevel / 100})`;
        canvas.style.transformOrigin = 'top center';
        document.getElementById('zoom-level').textContent = zoomLevel + '%';
        
        // Redibujar márgenes y actualizar regla después del zoom
        setTimeout(() => {
            dibujarMargenes();
            actualizarRegla();
        }, 100);
    }
}

function maximizarAlto() {
    const canvas = document.getElementById('report-canvas');
    if (!canvas) return;

    const canvasRect = canvas.getBoundingClientRect();
    const paddingInferior = 40; // espacio de respiración

    // Altura disponible en la ventana desde la parte superior del canvas
    const alturaDisponible = window.innerHeight - canvasRect.top - paddingInferior;
    const alturaNatural = canvas.offsetHeight; // altura real del canvas sin zoom

    if (alturaDisponible <= 0 || alturaNatural <= 0) {
        return;
    }

    const nuevaEscala = (alturaDisponible / alturaNatural) * 100;
    zoomLevel = Math.max(25, Math.min(200, Math.round(nuevaEscala)));
    aplicarZoom();

    setTimeout(() => {
        actualizarRegla();
        actualizarReglaVertical();
    }, 150);
}

function maximizarAncho() {
    const canvas = document.getElementById('report-canvas');
    if (!canvas) return;
    
    // Obtener el contenedor del canvas
    const canvasArea = canvas.closest('.canvas-area');
    if (!canvasArea) return;
    
    // Obtener ancho disponible (sin padding)
    const anchoDisponible = canvasArea.clientWidth - 60; // Padding
    
    // Obtener ancho natural del canvas sin zoom
    const canvasRect = canvas.getBoundingClientRect();
    const computedStyle = window.getComputedStyle(canvas);
    const anchoCSS = computedStyle.width;
    const mmToPx = 3.779527559;
    let anchoNaturalPx;
    if (anchoCSS.includes('mm')) {
        anchoNaturalPx = parseFloat(anchoCSS) * mmToPx;
    } else {
        anchoNaturalPx = parseFloat(anchoCSS);
    }
    const zoomFactorActual = canvasRect.width / anchoNaturalPx;
    const anchoNatural = canvasRect.width / zoomFactorActual; // Ancho sin zoom aplicado
    
    // Calcular nueva escala para que el canvas quepa exactamente en ancho
    if (anchoNatural > 0) {
        const nuevaEscala = (anchoDisponible / anchoNatural) * 100;
        zoomLevel = Math.max(25, Math.min(200, Math.round(nuevaEscala)));
        aplicarZoom();
        // Actualizar regla después de maximizar
        setTimeout(() => {
            actualizarRegla();
            actualizarReglaVertical();
        }, 150);
    }
}

function validarSeccionesPorTipo(tipoEstudio) {
    // Validar que todas las secciones del diseño sean compatibles con el tipo de estudio
    const seccionesValidas = seccionesPorTipo[tipoEstudio] || [];
    const seccionesIncompatibles = [];
    
    estructura.forEach(elem => {
        if (elem.tipo === 'seccion' && elem.seccion_codigo) {
            if (!seccionesValidas.includes(elem.seccion_codigo)) {
                seccionesIncompatibles.push({
                    elemento: elem,
                    codigo: elem.seccion_codigo,
                    contenido: elem.contenido
                });
            }
        }
    });
    
    return seccionesIncompatibles;
}

function convertirSecciones(tipoOrigen, tipoDestino) {
    const claveMapeo = `${tipoOrigen}->${tipoDestino}`;
    const mapeo = mapeoConversiones[claveMapeo] || {};
    const seccionesDestino = new Set(seccionesPorTipo[tipoDestino] || []);
    const titulosPorCodigo = {
        'DATOS_CLINICOS': 'DATOS CLÍNICOS',
        'EXTENDIDO': 'EXTENDIDO',
        'CELULAS_CONFORMACION': 'DESCRIPCIÓN CITOLÓGICA',
        'CELULAS_JUNTO_A': 'JUNTO A',
        'COMP_INFLAMATORIO': 'COMPONENTE INFLAMATORIO',
        'FLORA': 'FLORA',
        'MATERIAL_REMITIDO': 'MATERIAL REMITIDO',
        'DESCRIPCION_MACROSCOPICA': 'DESCRIPCIÓN MACROSCÓPICA',
        'DESCRIPCION_MICROSCOPICA': 'DESCRIPCIÓN MICROSCÓPICA',
        'DIAGNOSTICO': 'DIAGNÓSTICO'
    };
    let huboCambios = false;

    for (let i = estructura.length - 1; i >= 0; i--) {
        const elem = estructura[i];
        if (elem.tipo !== 'seccion' || !elem.seccion_codigo) {
            continue;
        }

        if (Object.prototype.hasOwnProperty.call(mapeo, elem.seccion_codigo)) {
            const nuevoCodigo = mapeo[elem.seccion_codigo];
            if (nuevoCodigo === null) {
                const div = document.getElementById(elem.id);
                if (div) div.remove();
                estructura.splice(i, 1);
                huboCambios = true;
                continue;
            }
            if (nuevoCodigo && nuevoCodigo !== elem.seccion_codigo) {
                elem.seccion_codigo = nuevoCodigo;
                huboCambios = true;
            }
        }

        if (!seccionesDestino.has(elem.seccion_codigo)) {
            const div = document.getElementById(elem.id);
            if (div) div.remove();
            estructura.splice(i, 1);
            huboCambios = true;
            continue;
        }

        const tituloActualizado = titulosPorCodigo[elem.seccion_codigo];
        if (tituloActualizado && elem.contenido !== tituloActualizado) {
            elem.contenido = tituloActualizado;
            huboCambios = true;
        }
    }

    if (huboCambios) {
        reordenarCanvas();
    }
    actualizarToolboxSecciones();
    return true;
}

function mostrarModalGuardar() {
    // Establecer el tipo de estudio actual en el modal
    const tipoEstudioSelect = document.getElementById('tipo-estudio');
    if (tipoEstudioSelect) {
        tipoEstudioSelect.value = tipoEstudioActual;
        // Validar al cambiar el tipo
        tipoEstudioSelect.onchange = function() {
            const nuevoTipo = this.value;
            const incompatibles = validarSeccionesPorTipo(nuevoTipo);
            
            if (incompatibles.length > 0) {
                const mensaje = `⚠️ ADVERTENCIA: Hay ${incompatibles.length} sección(es) incompatible(s) con "${nuevoTipo}":\n\n` +
                    incompatibles.map(s => `• ${s.contenido} (${s.codigo})`).join('\n') +
                    `\n\n¿Desea convertir automáticamente las secciones compatibles y eliminar las incompatibles?`;
                
                if (confirm(mensaje)) {
                    if (convertirSecciones(tipoEstudioActual, nuevoTipo)) {
                        tipoEstudioActual = nuevoTipo;
                        alert('✅ Secciones convertidas. Las incompatibles han sido eliminadas.');
                    } else {
                        alert('❌ No hay mapeo de conversión disponible entre estos tipos. Elimine manualmente las secciones incompatibles.');
                        this.value = tipoEstudioActual; // Revertir
                    }
                } else {
                    this.value = tipoEstudioActual; // Revertir si no se confirma
                }
            } else {
                tipoEstudioActual = nuevoTipo;
                // Actualizar toolbox cuando cambie el tipo
                actualizarToolboxSecciones();
            }
        };
    }
    
    const modal = new bootstrap.Modal(document.getElementById('modalGuardar'));
    modal.show();
}

function guardarEstructura() {
    const nombre = document.getElementById('nombre-disenio').value.trim();
    const tipoEstudio = document.getElementById('tipo-estudio').value;
    const esDefault = document.getElementById('es-default').checked;
    
    if (!nombre) {
        alert('❌ Por favor ingrese un nombre para el diseño');
        return;
    }
    
    // Validar secciones antes de guardar
    const seccionesIncompatibles = validarSeccionesPorTipo(tipoEstudio);
    if (seccionesIncompatibles.length > 0) {
        const mensaje = `❌ ERROR: Hay ${seccionesIncompatibles.length} sección(es) incompatible(s) con el tipo de estudio "${tipoEstudio}":\n\n` +
            seccionesIncompatibles.map(s => `• ${s.contenido} (${s.codigo})`).join('\n') +
            `\n\nPor favor, elimine estas secciones o cambie el tipo de estudio antes de guardar.`;
        alert(mensaje);
        return;
    }
    
    // Actualizar tipo de estudio actual
    tipoEstudioActual = tipoEstudio;
    
    // Actualizar el orden de los elementos basándose en el DOM antes de guardar
    actualizarOrdenDesdeDOM();
    
    // Asegurar que todos los elementos de tipo 'seccion' tengan su seccion_codigo guardado
    estructura.forEach(elem => {
        if (elem.tipo === 'seccion' && !elem.seccion_codigo) {
            // Si no tiene código, intentar obtenerlo del contenido o del nombre de la sección
            const contenido = elem.contenido || '';
            const contenidoUpper = contenido.toUpperCase();
            
            // Mapeo inverso: nombre -> código
            const mapeoInverso = {
                'DATOS CLÍNICOS': 'DATOS_CLINICOS',
                'MATERIAL REMITIDO': 'MATERIAL_REMITIDO',
                'DESCRIPCIÓN MACROSCÓPICA': 'DESCRIPCION_MACROSCOPICA',
                'DESCRIPCIÓN MICROSCÓPICA': 'DESCRIPCION_MICROSCOPICA',
                'DESCRIPCIÓN CITOLÓGICA': 'DESCRIPCION_MICROSCOPICA', // Para BIOPSIA
                'DIAGNÓSTICO': 'DIAGNOSTICO',
                'EXTENDIDO': 'EXTENDIDO',
                'JUNTO A': 'CELULAS_JUNTO_A',
                'COMPONENTE INFLAMATORIO': 'COMP_INFLAMATORIO',
                'FLORA': 'FLORA'
            };
            
            // Buscar coincidencia en el mapeo
            for (const [nombre, codigo] of Object.entries(mapeoInverso)) {
                if (contenidoUpper.includes(nombre.toUpperCase()) || nombre.toUpperCase().includes(contenidoUpper)) {
                    elem.seccion_codigo = codigo;
                    console.log(`Código deducido para "${contenido}": ${codigo}`);
                    break;
                }
            }
        }
    });
    
    const config = obtenerConfiguracionActual();
    config.estructura_visual = estructura;
    
    // Debug: mostrar estructura completa
    console.log('Estructura a guardar:', JSON.stringify(estructura, null, 2));
    console.log('Elementos por tipo:', estructura.reduce((acc, el) => {
        acc[el.tipo] = (acc[el.tipo] || 0) + 1;
        return acc;
    }, {}));
    // Verificar específicamente los elementos de datos
    const elementosDatos = estructura.filter(el => ['protocolo-fecha', 'datos-paciente', 'datos-medico', 'datos-paciente-medico'].includes(el.tipo));
    console.log('Elementos de datos encontrados:', elementosDatos.length, elementosDatos.map(el => ({ tipo: el.tipo, id: el.id, contenido: el.contenido })));
    
    // Actualizar configuración de secciones desde el panel
    const colorFondoTitulo = document.getElementById('config-color-fondo-titulo');
    const colorTituloTexto = document.getElementById('config-color-titulo-texto');
    const colorVineta = document.getElementById('config-color-vineta');
    const colorContenido = document.getElementById('config-color-contenido');
    
    // Obtener configuración de títulos
    const tamanoTitulo = document.getElementById('config-tamano-titulo');
    const fuenteTitulo = document.getElementById('config-fuente-titulo');
    const alineacionTitulo = document.getElementById('config-alineacion-titulo');
    const tituloNegrita = document.getElementById('config-titulo-negrita');
    const tituloCursiva = document.getElementById('config-titulo-cursiva');
    
    config.secciones = Object.assign(config.secciones || {}, {
        // Configuración de TÍTULOS
        color_fondo_titulo: normalizarColor(colorFondoTitulo ? colorFondoTitulo.value : '#e3f2fd') || '#e3f2fd',
        titulo_color: normalizarColor(colorTituloTexto ? colorTituloTexto.value : '#007bff') || '#007bff',
        titulo_tamano: parseInt(tamanoTitulo ? tamanoTitulo.value : 14) || 14,
        titulo_fuente: fuenteTitulo ? fuenteTitulo.value : 'Arial',
        titulo_alineacion: alineacionTitulo ? alineacionTitulo.value : 'left',
        titulo_negrita: tituloNegrita ? tituloNegrita.checked : false,
        titulo_cursiva: tituloCursiva ? tituloCursiva.checked : false,
        // Configuración de CONTENIDO
        indentacion: parseInt(document.getElementById('config-indentacion').value) || 15,
        mostrar_vinetas: document.getElementById('config-mostrar-vinetas').checked,
        color_vineta: normalizarColor(colorVineta ? colorVineta.value : '#007bff') || '#007bff',
        alineacion_contenido: document.getElementById('config-alineacion-contenido').value || 'left',
        contenido_fuente: document.getElementById('config-fuente-contenido').value || 'Arial',
        contenido_tamano: parseInt(document.getElementById('config-tamano-contenido').value) || 12,
        contenido_color: normalizarColor(colorContenido ? colorContenido.value : '#333333') || '#333333',
        contenido_negrita: document.getElementById('config-contenido-negrita').checked || false,
        contenido_cursiva: document.getElementById('config-contenido-cursiva').checked || false
    });
    
    // Obtener tamaño de papel seleccionado
    const tamanoPapel = document.getElementById('tamano-papel').value;
    if (!config.impresion) config.impresion = {};
    config.impresion.tamaño_papel = tamanoPapel;
    
    // Guardar dimensiones personalizadas si están configuradas
    if (tamanoPapel === 'personalizado') {
        const ancho = document.getElementById('ancho-personalizado').value;
        const alto = document.getElementById('alto-personalizado').value;
        if (!config.impresion.dimensiones_personalizadas) {
            config.impresion.dimensiones_personalizadas = {};
        }
        config.impresion.dimensiones_personalizadas.ancho = parseFloat(ancho) || 210;
        config.impresion.dimensiones_personalizadas.alto = parseFloat(alto) || 297;
    }
    
    // Preparar datos para guardar
    const datosGuardado = {
        nombre: nombre,
        tipo_estudio: tipoEstudio,
        es_default: esDefault,
        estructura: estructura,
        configuracion: config
    };
    
    // Cerrar modal de guardar primero
    const modal = bootstrap.Modal.getInstance(document.getElementById('modalGuardar'));
    if (modal) modal.hide();

    const requiereDecisionCambioTipo = disenioId && disenioId > 0 && tipoEstudioInicial && tipoEstudio !== tipoEstudioInicial;

    const continuarConGuardado = (modo) => {
        if (modo) {
            datosGuardado.modo_tipo = modo;
        }
        // Mostrar diálogo de confirmación con tres opciones
        mostrarDialogoConfirmacionGuardar(datosGuardado);
    };

    if (requiereDecisionCambioTipo) {
        solicitarDecisionCambioTipo(tipoEstudioInicial, tipoEstudio)
            .then(decision => {
                if (!decision) {
                    return;
                }
                continuarConGuardado(decision);
            });
        return;
    }

    continuarConGuardado('mover');
}

function mostrarDialogoConfirmacionGuardar(datosGuardado) {
    // Crear modal de confirmación si no existe
    let modalConfirmacion = document.getElementById('modalConfirmacionGuardar');
    if (!modalConfirmacion) {
        modalConfirmacion = document.createElement('div');
        modalConfirmacion.id = 'modalConfirmacionGuardar';
        modalConfirmacion.className = 'modal fade';
        modalConfirmacion.innerHTML = `
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">
                            <i class="bi bi-question-circle"></i> Confirmar Guardado
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body text-center">
                        <p class="mb-4">¿Qué desea hacer?</p>
                        <div id="nota-guardar-disenio" class="alert alert-info text-start" style="display: none;"></div>
                        <div class="d-grid gap-2">
                            <button type="button" class="btn btn-success" id="btn-guardar-continuar">
                                <i class="bi bi-save"></i> Guardar y Continuar
                            </button>
                            <button type="button" class="btn btn-primary" id="btn-guardar">
                                <i class="bi bi-save"></i> Guardar
                            </button>
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                                <i class="bi bi-x-circle"></i> Cancelar
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(modalConfirmacion);
    }
    
    // Remover listeners anteriores si existen
    const btnGuardar = document.getElementById('btn-guardar');
    const btnGuardarContinuar = document.getElementById('btn-guardar-continuar');
    
    // Clonar y reemplazar para remover listeners anteriores
    const nuevoBtnGuardar = btnGuardar.cloneNode(true);
    const nuevoBtnGuardarContinuar = btnGuardarContinuar.cloneNode(true);
    btnGuardar.parentNode.replaceChild(nuevoBtnGuardar, btnGuardar);
    btnGuardarContinuar.parentNode.replaceChild(nuevoBtnGuardarContinuar, btnGuardarContinuar);
    
    const notaGuardado = document.getElementById('nota-guardar-disenio');
    if (notaGuardado) {
        const modoTipo = datosGuardado.modo_tipo || 'mover';
        if (disenioId && disenioId > 0 && datosGuardado.tipo_estudio !== tipoEstudioInicial) {
            notaGuardado.style.display = 'block';
            if (modoTipo === 'copiar') {
                notaGuardado.textContent = `Se creará una copia en "${datosGuardado.tipo_estudio}" y se conservará el diseño original en "${tipoEstudioInicial}".`;
            } else {
                notaGuardado.textContent = `El diseño se moverá al tipo "${datosGuardado.tipo_estudio}".`;
            }
        } else {
            notaGuardado.style.display = 'none';
            notaGuardado.textContent = '';
        }
    }
    
    // Agregar event listeners con los datos actuales
    nuevoBtnGuardar.addEventListener('click', function() {
        ejecutarGuardado(datosGuardado, false); // false = no continuar
    });
    
    nuevoBtnGuardarContinuar.addEventListener('click', function() {
        ejecutarGuardado(datosGuardado, true); // true = continuar
    });
    
    // Mostrar modal
    const modal = new bootstrap.Modal(modalConfirmacion);
    modal.show();
}

function solicitarDecisionCambioTipo(tipoOrigen, tipoDestino) {
    return new Promise(resolve => {
        let modalDecision = document.getElementById('modalDecisionCambioTipo');
        if (!modalDecision) {
            modalDecision = document.createElement('div');
            modalDecision.id = 'modalDecisionCambioTipo';
            modalDecision.className = 'modal fade';
            modalDecision.innerHTML = `
                <div class="modal-dialog modal-dialog-centered">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="bi bi-journal-plus"></i> Cambiar tipo de estudio
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <p id="mensaje-decision-tipo" class="mb-4"></p>
                            <div class="d-grid gap-2">
                                <button type="button" class="btn btn-success" id="btn-decision-copiar">
                                    <i class="bi bi-files"></i> Crear copia y conservar original
                                </button>
                                <button type="button" class="btn btn-primary" id="btn-decision-mover">
                                    <i class="bi bi-arrow-right-circle"></i> Mover diseño al nuevo tipo
                                </button>
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                                    <i class="bi bi-x-circle"></i> Cancelar
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modalDecision);
        }

        const mensaje = modalDecision.querySelector('#mensaje-decision-tipo');
        if (mensaje) {
            mensaje.innerHTML = `El diseño cambió de "<strong>${tipoOrigen}</strong>" a "<strong>${tipoDestino}</strong>".<br><br>` +
                `¿Desea conservar el diseño original y crear una copia para el nuevo tipo o moverlo definitivamente?`;
        }

        const btnCopiar = modalDecision.querySelector('#btn-decision-copiar');
        const btnMover = modalDecision.querySelector('#btn-decision-mover');

        const nuevoBtnCopiar = btnCopiar.cloneNode(true);
        const nuevoBtnMover = btnMover.cloneNode(true);
        btnCopiar.parentNode.replaceChild(nuevoBtnCopiar, btnCopiar);
        btnMover.parentNode.replaceChild(nuevoBtnMover, btnMover);

        const modalBootstrap = new bootstrap.Modal(modalDecision);
        let resuelto = false;

        const resolver = (valor) => {
            if (!resuelto) {
                resuelto = true;
                modalBootstrap.hide();
                resolve(valor);
            }
        };

        nuevoBtnCopiar.addEventListener('click', () => resolver('copiar'));
        nuevoBtnMover.addEventListener('click', () => resolver('mover'));

        modalDecision.addEventListener('hidden.bs.modal', function handler() {
            modalDecision.removeEventListener('hidden.bs.modal', handler);
            if (!resuelto) {
                resuelto = true;
                resolve(null);
            }
        });

        modalBootstrap.show();
    });
}

function ejecutarGuardado(datosGuardado, continuar) {
    // Cerrar modal de confirmación
    const modalConfirmacion = bootstrap.Modal.getInstance(document.getElementById('modalConfirmacionGuardar'));
    if (modalConfirmacion) modalConfirmacion.hide();
    
    const modoTipo = datosGuardado.modo_tipo || 'mover';
    let urlGuardar;
    if (modoTipo === 'copiar') {
        urlGuardar = `/admin/disenios-informes/0/guardar-estructura`;
    } else {
        urlGuardar = disenioId && disenioId > 0 ? 
            `/admin/disenios-informes/${disenioId}/guardar-estructura` : 
            `/admin/disenios-informes/0/guardar-estructura`;
    }
    
    fetch(urlGuardar, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(datosGuardado)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('✅ Diseño guardado correctamente');
            if (data.disenio_id) {
                if (modoTipo === 'copiar') {
                    disenioId = data.disenio_id;
                } else if (!disenioId || disenioId === 0) {
                    disenioId = data.disenio_id;
                }
            }
            tipoEstudioInicial = datosGuardado.tipo_estudio;
            tipoEstudioActual = datosGuardado.tipo_estudio;
            if (continuar) {
                // Guardar y continuar: no redirigir, solo cerrar modales
                // El usuario puede seguir editando
                if (disenioId && disenioId > 0) {
                    const nuevaUrl = `/admin/disenios-informes/${disenioId}/visual`;
                    if (window.location.pathname !== nuevaUrl) {
                        window.history.replaceState(null, '', nuevaUrl);
                    }
                }
            } else {
                // Guardar: redirigir al gestor
                setTimeout(() => {
                    window.location.href = '/admin/disenios-informes';
                }, 1000);
            }
        } else {
            alert('❌ Error: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('❌ Error al guardar');
    });
}
</script>
{% endblock %}

